---
doc_type: weread-highlights-reviews
bookId: "26211813"
author: Raoul-Gabriel Urma Mario Fusco Alan Mycroft
cover: https://cdn.weread.qq.com/weread/cover/84/YueWen_26211813/t7_YueWen_26211813.jpg
reviewCount: 3
noteCount: 20
readingStatus: 读完
progress: 74%
totalReadDay: 44
readingTime: 12小时8分钟
readingDate: 2020-07-25
finishedDate: 2022-04-22
isbn: 9787115419347
lastReadDate: 2020-08-17

---
# 元数据
> [!abstract] Java 8实战
> - ![ Java 8实战|200](https://cdn.weread.qq.com/weread/cover/84/YueWen_26211813/t7_YueWen_26211813.jpg)
> - 书名： Java 8实战
> - 作者： Raoul-Gabriel Urma Mario Fusco Alan Mycroft
> - 简介： 本书全面介绍了Java 8 这个里程碑版本的新特性，包括Lambdas、流和函数式编程。有了函数式的编程特性，可以让代码更简洁，同时也能自动化地利用多核硬件。全书分四个部分：基础知识、函数式数据处理、高效Java 8 编程和超越Java 8，清晰明了地向读者展现了一幅Java 与时俱进的现代化画卷。
> - 出版时间 2016-04-25 00:00:00
> - ISBN： 9787115419347
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/faf32510718ff5e5fafd211

# 高亮划线

## 封面

## 版权信息

## 数字版权声明

## 作者简介

## 版权声明

## 献词

## 序言

## 致谢

## 关于本书

## 关于封面图

## 第一部分 基础知识

### 第1章 为什么要关心Java 8

> 📌 Java 1.0里有线程和锁，甚至有一个内存模型——这是当时的最佳做法，但事实证明，不具备专门知识的项目团队很难可靠地使用这些基本模型。Java 5添加了工业级的构建模块，如线程池和并发集合。Java 7添加了分支/合并（fork/join）框架，使得并行变得更实用，但仍然很困难。而Java 8对并行有了一个更简单的新思路，不过你仍要遵循一些规则，本书中会谈到 
> ⏱ 2020-07-25 22:07:30 ^26211813-12-1903-2084

> 📌 从有点修正主义的角度来看，在Java 8中加入Streams可以看作把另外两项扩充加入Java 8的直接原因：把代码传递给方法的简洁方式（方法引用、Lambda）和接口中的默认方法。 
> ⏱ 2020-07-25 22:08:02 ^26211813-12-2698-2789

> 📌 Java 8里面将代码传递给方法的功能（同时也能够返回代码并将其包含在数据结构中）还让我们能够使用一整套新技巧，通常称为函数式编程 
> ⏱ 2020-07-25 22:09:06 ^26211813-12-3084-3149

### 第2章 通过行为参数化传递代码

> 📌 还是需要一种方式来区分想 
> ⏱ 2020-07-26 17:56:38 ^26211813-13-4327-4339

> 📌 行为参数化的好处在于你可以把迭代要筛选的集合的逻辑与对集合中每个元素应用的行为区分开来。 
> ⏱ 2020-07-27 08:29:18 ^26211813-13-8685-8729

> 📌 Java有一个机制称为匿名类，它可以让你同时声明和实例化一个类 
> ⏱ 2020-07-27 08:42:56 ^26211813-13-12495-12554

> 📌 用一个Comparator排序，用Runnable执行一个代码块，以及GUI事件处理。 
> ⏱ 2020-07-28 08:04:23 ^26211813-13-16529-16572

> 📌 行为参数化，就是一个方法接受多个不同的行为作为参数，并在内部使用它们，完成不同行为的能力。❑ 行为参数化可让代码更好地适应不断变化的要求，减轻未来的工作量。❑ 传递代码，就是将新行为作为参数传递给方法。但在Java 8之前这实现起来很啰嗦。为接口声明许多只用一次的实体类而造成的啰嗦代码，在Java 8之前可以用匿名类来减少。❑ Java API包含很多可以用不同行为进行参数化的方法，包括排序、线程和GUI处理。 
> ⏱ 2020-07-28 08:11:23 ^26211813-13-19371-19724

### 第3章 Lambda表达式

> 📌 Lambda表达式理解为简洁地表示可传递的匿名函数的一种方式：它没有名称，但它有参数列表、函数主体、返回类型，可能还有一个可以抛出的异常列表。这个定义够大的，让我们慢慢道来。 
> ⏱ 2020-07-28 08:16:20 ^26211813-14-1571-1686

> 📌 函数式接口就是只定义一个抽象方法的接口。你已经知道了Java API中的一些其他函数式接口，如我们在第2章中谈到的Comparator和 
> ⏱ 2020-07-29 08:07:43 ^26211813-14-6643-6711

> 📌 函数式接口的抽象方法的签名称为函数描述符。 
> ⏱ 2020-07-29 12:44:33 ^26211813-14-15283-15304

> 📌 因为函数描述符可以通过目标类型来得到。这样做的好处在于 
> ⏱ 2020-08-04 08:14:50 ^26211813-14-26469-26496

> 📌 请注意，有时候显式写出类型更易读，有时候去掉它们更易读。没有什么法则说哪种更好；对于如何让代码更易读，程序员必须做出自己的选择 
> ⏱ 2020-08-04 08:15:31 ^26211813-14-27168-27231

> 📌 实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。 
> ⏱ 2020-08-04 08:17:26 ^26211813-14-27711-27750

> 📌 inventory.sort(comparing(Apple::getWeight));
3.7.1 第1步：传递代码
你很幸运，Java 8的API已经为你提供了一个List可用的sort方法，你不用自己去实现它。那么最困难的部分已经搞定了！但是，如何把排序策略传递给sort方法呢？你看，sort方法的签名是这样的：
         void sort(Comparator<? super E> c)
它需要一个Comparator对象来比较两个Apple！这就是在Java中传递策略的方式：它们必须包裹在一个对象里。我们说sort的行为被参数化了：传递给它的排序策略不同，其行为也会不同。
你的第一个解决方案看上去是这样的：
         public class AppleComparator implements Comparator<Apple> { 
> ⏱ 2020-08-09 23:53:43 ^26211813-14-36991

> 📌 Lambda说明了如何从苹果中提取需要比较的键值）： 
> ⏱ 2020-08-10 00:19:36 ^26211813-14-39260-39286

> 📌 and和or方法是按照在表达式链中的位置，从左向右确定优先级的 
> ⏱ 2020-08-10 12:24:53 ^26211813-14-42496-42527

## 第二部分 函数式数据处理

### 第4章 引入流

> 📌 支持数据处理操作的源生成的元素序列” 
> ⏱ 2020-08-14 08:36:28 ^26211813-16-7319-7337

### 第5章 使用流

> 📌 flatMap方法的效果是，各个数组并不是分别映射成一个流，而是映射成流的内容 
> ⏱ 2020-08-15 11:20:11 ^26211813-17-8767-8806

### 第6章 用流收集数据

> 📌 就像你刚刚看到的，在需要将流项目重组成集合时，一般会使用收集器（Stream方法collect的参数）。再宽泛一点来说，但凡要把流中所有的项目合并成一个结果时就可以用。这个结果可以是任何类型，可以复杂如代表一棵树的多级映射，或是简单如一个整数——也许代表了菜单的热量总和。这两种结果类型我们都会讨论：6.2.2节讨论单个整数，6.3.1节讨论多级分组。 
> ⏱ 2020-08-15 15:22:04 ^26211813-18-4797-4973

### 第7章 并行数据处理与性能

## 第三部分 高效Java 8编程

### 第8章 重构、测试和调试

> 📌 在匿名类中，this代表的是类自身，但是在Lambda中，它代表的是包含类。其次，匿名类可以屏蔽包含类的变量，而Lambda表达式不能（它们会导致编译错误），譬如下面这段代码： 
> ⏱ 2020-08-16 16:43:58 ^26211813-21-3031-3119

### 第9章 默认方法

### 第10章 用Optional取代null

### 第11章 CompletableFuture：组合式异步编程

### 第12章 新的日期和时间API

## 第四部分 超越Java 8

### 第13章 函数式的思考

### 第14章 函数式编程的技巧

### 第15章 面向对象和函数式编程的混合：Java 8和Scala的比较

### 第16章 结论以及Java的未来

## 附录A 其他语言特性的更新

### A.1 注解

### A.2 通用目标类型推断

## 附录B 类库的更新

### B.1 集合

### B.2 并发

### B.3 Arrays

### B.4 Number和Math

### B.5 Files

### B.6 Reflection

### B.7 String

## 附录C 如何以并发方式在同一个流上执行多种操作

### C.1 复制流

### C.2 性能的考量

## 附录D Lambda表达式和JVM字节码

### D.1 匿名类

### D.2 生成字节码

### D.3 用InvokeDynamic力挽狂澜

### D.4 代码生成策略

## 看完了

# 读书笔记

## 第3章 Lambda表达式

### 划线评论
> 📌 (1) ()-> {}(2) ()-> "Raoul"(3) ()-> {return "Mario"; }(4) (Integer i)-> return "Alan"+i;(5) (String s)-> {"IronMan"; }答案：只有4和5是无效的Lambda。(1) 这个Lambda没有参数，并返回void。它类似于主体为空的方法：public void run() {}。(2) 这个Lambda没有参数，并返回String作为表达式。(3) 这个Lambda没有参数，并返回String（利用显式返回语句）。(4) return是一个控制流语句。要使此Lambda有效，需要使花括号，如下所示：(Integer i)->{return "Alan"+i; }。(5)“Iron Man”是一个表达式，不是一个语句。要使此Lambda有效，你可以去除花括号和分号，如下所示：(String s)-> "Iron Man"。或者如果你喜欢，可以使用显式返回语句，如下所示：(String s)->{return "IronMan"; }。  ^14417636-7jaFRs3p8
    - 💭 表达式和语句分别是什么？
表达式没有分号，以及大括号，默认return
语句必须带分号以及大括号
    - ⏱ 2020-07-28 08:56:10
   
## 第8章 重构、测试和调试

### 划线评论
> 📌 改善代码的可读性到底意味着什么？我们很难定义什么是好的可读性，因为这可能非常主观。通常的理解是，“别人理解这段代码的难易程度”。改善可读性意味着你要确保你的代码能非常容易地被包括自己在内的所有人理解和维护。为了确保你的代码能被其他人理解，有几个步骤可以尝试，比如确保你的代码附有良好的文档，并严格遵守编程规范。  ^14417636-7jFZZACJ2
    - 💭 这本书读起来真的容易懂
    - ⏱ 2020-08-17 23:10:20

### 划线评论
> 📌 你可以对Task尝试使用显式的类型转换来解决这种模棱两可的情况：  ^14417636-7jE4yJMyT
    - 💭 在lambda表达式一样的重载函数中可以使用强转
    - ⏱ 2020-08-16 16:46:44
   
# 本书评论
