---
doc_type: weread-highlights-reviews
bookId: "34336683"
author: 马特·弗里斯比
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/683/34336683/t7_34336683.jpg
reviewCount: 1
noteCount: 22
readingStatus: 在读
progress: 46%
totalReadDay: 17
readingTime: 7小时23分钟
readingDate: 2023-06-03
isbn: 9787115545381
lastReadDate: 2023-08-07

---
# 元数据
> [!abstract] JavaScript高级程序设计（第4版）
> - ![ JavaScript高级程序设计（第4版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/683/34336683/t7_34336683.jpg)
> - 书名： JavaScript高级程序设计（第4版）
> - 作者： 马特·弗里斯比
> - 简介： 本书是JavaScript经典图书的新版。第4版涵盖ECMAScript2019，全面、深入地介绍了JavaScript开发者必须掌握的前端开发技术，涉及JavaScript的基础特性和高级特性。书中详尽讨论了JavaScript的各个方面，从JavaScript的起源开始，逐步讲解到新出现的技术，其中重点介绍ECMAScript和DOM标准。在此基础上，接下来的各章揭示了JavaScript的基本概念，包括类、期约、迭代器、代理，等等。另外，书中深入探讨了客户端检测、事件、动画、表单、错误处理及JSON。本书同时也介绍了近几年来涌现的重要新规范，包括FetchAPI、模块、工作者线程、服务线程以及大量新API。
> - 出版时间 2020-09-11 00:00:00
> - ISBN： 9787115545381
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/751326d0720befab7514782

# 高亮划线

## 封面

## 版权信息

## 作者简介

## 译者简介

## 数字版权声明

## 献辞

## 译者序

## 序

## 前言

## 致谢

## 第1章 什么是JavaScript

### 1.1 简短的历史回顾

### 1.2 JavaScript实现

### 1.3 JavaScript版本

### 1.4 小结

## 第2章 HTML中的JavaScript

### 2.1 <script>元素

> 📌 浏览器解析行内脚本的方式决定了它在看到字符串</script>时，会将其当成结束的</script>标签。想避免这个问题，只需要转义字符“\”￼即可：
​​​​​​<script>￼ 
> ⏱ 2023-06-10 08:01:21 ^34336683-17-2709-2935

> 📌 包含外部文件中的JavaScript，就必须使用src属性。这个属性的值是一个URL，指向包含JavaScript代码的文件 
> ⏱ 2023-06-10 08:01:38 ^34336683-17-3161-3223

> 📌 使用了src属性的<script>元素不应该再在<script>和</script>标签中再包含其他JavaScript代码。如果两者都提供的话，则浏览器只会下载并执行脚本文件，从而忽略行内代码。 
> ⏱ 2023-06-10 08:05:36 ^34336683-17-3941-4039

### 2.2 行内代码与外部文件

### 2.3 文档模式

### 2.4 <noscript>元素

### 2.5 小结

## 第3章 语言基础

### 3.1 语法

> 📌 ECMAScript中一切都区分大小写 
> ⏱ 2023-06-10 11:38:09 ^34336683-23-608-627

> 📌  use strict";​​ ^34336683-23-2000-2014
- 💭 启用严格模式 - ⏱ 2023-06-10 11:40:32 

> 📌 语句末尾的分号不是必需的，也应该加上 
> ⏱ 2023-06-10 11:42:49 ^34336683-23-2663-2681

### 3.2 关键字与保留字

### 3.3 变量

> 📌 有3个关键字可以声明变量：var、const和let。其中，var在ECMAScript的所有版本中都可以使用，而const和let只能在ECMAScript 6及更晚的版本中使用。 
> ⏱ 2023-06-10 11:46:37 ^34336683-25-716-807

> 📌 去掉之前的var操作符之后，message就变成了全局变量。只要调用一次函数test()，就会定义这个变量，并且可以在函数外部访问到。 
> ⏱ 2023-06-10 12:17:26 ^34336683-25-2161-2228

> 📌 在严格模式下，如果像这样给未声明的变量赋值，则会导致抛出ReferenceError。 
> ⏱ 2023-06-10 12:18:10 ^34336683-25-2371-2414

> 📌 所谓的“提升”（hoist），也就是把所有变量声明都拉到函数作用域的顶部 
> ⏱ 2023-08-07 10:11:21 ^34336683-25-3269-3305

> 📌 let声明的范围是块作用域，而var声明的范围是函数作用域。 
> ⏱ 2023-06-10 12:19:41 ^34336683-25-3621-3651

> 📌 块作用域是函数作用域的子集 
> ⏱ 2023-08-07 10:15:35 ^34336683-25-3990-4003

> 📌 let也不允许同一个块作用域中出现冗余声明 
> ⏱ 2023-06-10 13:37:46 ^34336683-25-4057-4078

> 📌 const的行为与let基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改const声明的变量会导致运行时错误 
> ⏱ 2023-06-11 12:12:18 ^34336683-25-8146-8213

> 📌 const声明的限制只适用于它指向的变量的引用。换句话说，如果const变量引用的是一个对象，那么修改这个对象内部的属性并不违反const的限制。 
> ⏱ 2023-06-10 16:30:29 ^34336683-25-8545-8618

> 📌 如果你只想用const声明一个不会被修改的for循环变量，那也是可以的。也就是说，每次迭代只是创建一个新变量。这对for-of和for-in循环特别有意义：
​​​​​​let i = 0;￼ 
> ⏱ 2023-06-10 16:35:30 ^34336683-25-8919-9027

### 3.4 数据类型

> 📌 因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一：❑ "undefined"表示值未定义；❑ "boolean"表示值为布尔值；❑ "string"表示值为字符串；❑ "number"表示值为数值；❑ "object"表示值为对象（而不是函数）或null；❑ "function"表示值为函数；❑ "symbol"表示值为符号。 
> ⏱ 2023-06-11 13:19:04 ^34336683-26-803-1238

> 📌 调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。 
> ⏱ 2023-06-11 13:20:09 ^34336683-26-1670-1721

> 📌 无论是声明还是未声明，typeof返回的都是字符串"undefined" 
> ⏱ 2023-08-07 11:10:46 ^34336683-26-3610-3646

> 📌 NaN不等于包括NaN在内的任何值 
> ⏱ 2023-08-07 13:11:04 ^34336683-26-10798-10815

> 📌 null和undefined值没有toString()方法 
> ⏱ 2023-08-07 13:32:07 ^34336683-26-17951-17980

### 3.5 操作符

> 📌 按位非的最终效果是对数值取反并减1 
> ⏱ 2023-08-07 13:56:40 ^34336683-27-8170-8187

### 3.6 语句

### 3.7 函数

### 3.8 小结

## 第4章 变量、作用域与内存

### 4.1 原始值与引用值

### 4.2 执行上下文与作用域

### 4.3 垃圾回收

### 4.4 小结

## 第5章 基本引用类型

### 5.1 Date

### 5.2 RegExp

### 5.3 原始值包装类型

### 5.4 单例内置对象

### 5.5 小结

## 第6章 集合引用类型

### 6.1 Object

### 6.2 Array

### 6.3 定型数组

### 6.4 Map

### 6.5 WeakMap

### 6.6 Set

### 6.7 WeakSet

### 6.8 迭代与扩展操作

### 6.9 小结

## 第7章 迭代器与生成器

### 7.1 理解迭代

### 7.2 迭代器模式

### 7.3 生成器

### 7.4 小结

## 第8章 对象、类与面向对象编程

### 8.1 理解对象

### 8.2 创建对象

### 8.3 继承

### 8.4 类

### 8.5 小结

## 第9章 代理与反射

### 9.1 代理基础

### 9.2 代理捕获器与反射方法

### 9.3 代理模式

### 9.4 小结

## 第10章 函数

### 10.1 箭头函数

### 10.2 函数名

### 10.3 理解参数

### 10.4 没有重载

### 10.5 默认参数值

### 10.6 参数扩展与收集

### 10.7 函数声明与函数表达式

### 10.8 函数作为值

### 10.9 函数内部

### 10.10 函数属性与方法

### 10.11 函数表达式

### 10.12 递归

### 10.13 尾调用优化

### 10.14 闭包

### 10.15 立即调用的函数表达式

### 10.16 私有变量

### 10.17 小结

## 第11章 期约与异步函数

### 11.1 异步编程

### 11.2 期约

### 11.3 异步函数

### 11.4 小结

## 第12章 BOM

### 12.1 window对象

### 12.2 location对象

### 12.3 navigator对象

### 12.4 screen对象

### 12.5 history对象

### 12.6 小结

## 第13章 客户端检测

### 13.1 能力检测

### 13.2 用户代理检测

### 13.3 软件与硬件检测

### 13.4 小结

## 第14章 DOM

### 14.1 节点层级

### 14.2 DOM编程

### 14.3 MutationObserver接口

### 14.4 小结

## 第15章 DOM扩展

### 15.1 Selectors API

### 15.2 元素遍历

### 15.3 HTML5

### 15.4 专有扩展

### 15.5 小结

## 第16章 DOM2和DOM3

### 16.1 DOM的演进

### 16.2 样式

### 16.3 遍历

### 16.4 范围

### 16.5 小结

## 第17章 事件

### 17.1 事件流

### 17.2 事件处理程序

### 17.3 事件对象

### 17.4 事件类型

### 17.5 内存与性能

### 17.6 模拟事件

### 17.7 小结

## 第18章 动画与Canvas图形

### 18.1 使用requestAnimationFrame

### 18.2 基本的画布功能

### 18.3 2D绘图上下文

### 18.4 WebGL

### 18.5 小结

## 第19章 表单脚本

### 19.1 表单基础

### 19.2 文本框编程

### 19.3 选择框编程

### 19.4 表单序列化

### 19.5 富文本编辑

### 19.6 小结

## 第20章 JavaScriptAPI

### 20.1 Atomics与SharedArrayBuffer

### 20.2 跨上下文消息

### 20.3 Encoding API

### 20.4 File API与Blob API

### 20.5 媒体元素

### 20.6 原生拖放

### 20.7 Notifications API

### 20.8 Page Visibility API

### 20.9 Streams API

### 20.10 计时API

### 20.11 Web组件

### 20.12 Web Cryptography API

### 20.13 小结

## 第21章 错误处理与调试

### 21.1 浏览器错误报告

### 21.2 错误处理

### 21.3 调试技术

### 21.4 旧版IE的常见错误

### 21.5 小结

## 第22章 处理XML

### 22.1 浏览器对XML DOM的支持

### 22.2 浏览器对XPath的支持

### 22.3 浏览器对XSLT的支持

### 22.4 小结

## 第23章 JSON

### 23.1 语法

### 23.2 解析与序列化

### 23.3 小结

## 第24章 网络请求与远程资源

### 24.1 XMLHttpRequest对象

### 24.2 进度事件

### 24.3 跨源资源共享

### 24.4 替代性跨源技术

### 24.5 Fetch API

### 24.6 Beacon API

### 24.7 Web Socket

### 24.8 安全

### 24.9 小结

## 第25章 客户端存储

### 25.1 cookie

### 25.2 Web Storage

### 25.3 IndexedDB

### 25.4 小结

## 第26章 模块

### 26.1 理解模块模式

### 26.2 凑合的模块系统

### 26.3 使用ES6之前的模块加载器

### 26.4 使用ES6模块

### 26.5 小结

## 第27章 工作者线程

### 27.1 工作者线程简介

### 27.2 专用工作者线程

### 27.3 共享工作者线程

### 27.4 服务工作者线程

### 27.5 小结

## 第28章 最佳实践

### 28.1 可维护性

### 28.2 性能

### 28.3 部署

### 28.4 小结

## 附录A ES2018和ES2019

### A.1 异步迭代

### A.2 对象字面量的剩余操作符和扩展操作符

### A.3 Promise.prototype.finally()

### A.4 正则表达式相关特性

### A.5 数组打平方法

### A.6 Object.fromEntries()

### A.7 字符串修理方法

### A.8 Symbol.prototype.description

### A.9 可选的catch绑定

### A.10 其他新增内容

## 附录B 严格模式

### B.1 选择使用

### B.2 变量

### B.3 对象

### B.4 函数

### B.5 this强制转型

### B.6 类与模块

### B.7 其他变化

## 附录C JavaScript库和框架

### C.1 框架

### C.2 通用库

### C.3 动画与特效

## 附录D JavaScript工具

### D.1 包管理

### D.2 模块加载器

### D.3 模块打包器

### D.4 编译/转译工具及静态类型系统

### D.5 高性能脚本工具

### D.6 编辑器

### D.7 构建工具、自动化系统和任务运行器

### D.8 代码检查和格式化

### D.9 压缩工具

### D.10 单元测试

### D.11 文档生成器

# 读书笔记

## 3.1 语法

### 划线评论
> 📌 use strict";  ^14417636-7IRsEZvpq
    - 💭 启用严格模式
    - ⏱ 2023-06-10 11:40:51
   
# 本书评论
