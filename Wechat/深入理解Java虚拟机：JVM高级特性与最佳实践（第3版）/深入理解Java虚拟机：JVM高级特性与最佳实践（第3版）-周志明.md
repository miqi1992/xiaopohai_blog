---
doc_type: weread-highlights-reviews
bookId: "27371406"
author: 周志明
cover: https://cdn.weread.qq.com/weread/cover/14/YueWen_27371406/t7_YueWen_27371406.jpg
reviewCount: 0
noteCount: 7
readingStatus: 读完
progress: 37%
totalReadDay: 8
readingTime: 3小时19分钟
readingDate: 2021-03-15
finishedDate: 2023-06-26
isbn: 9787111641247
lastReadDate: 2021-03-15

---
# 元数据
> [!abstract] 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）
> - ![ 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）|200](https://cdn.weread.qq.com/weread/cover/14/YueWen_27371406/t7_YueWen_27371406.jpg)
> - 书名： 深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）
> - 作者： 周志明
> - 简介： 本书一共分为五个部分：走近Java、自动内存管理、虚拟机执行子系统、程序编译与代码优化、高效并发。各个部分之间基本上是互相独立的，没有必然的前后依赖关系，读者可以从任何一个感兴趣的专题开始阅读，但是每个部分各个章节间则有先后顺序。
> - 出版时间 2019-11-01 00:00:00
> - ISBN： 9787111641247
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/cf1320d071a1a78ecf19254

# 高亮划线

## 封面

## 版权信息

## 前言

> 📌 主要的变化是JDK 8时期的永久代的落幕和元空间的登场 
> ⏱ 2021-03-15 15:30:43 ^27371406-3-5379-5406

## 致谢

## 第一部分 走近Java

#### 1.1 概述

#### 1.2 Java技术体系

> 📌 Java程序设计语言、Java虚拟机、Java类库这三部分统称为JDK（Java Development Kit），JDK是用于支持Java程序开发的最小环境 
> ⏱ 2021-03-15 15:46:02 ^27371406-7-901-980

#### 1.3 Java发展史

#### 1.4 Java虚拟机家族

#### 1.5 展望Java技术的未来

#### 1.6 实战：自己编译JDK

#### 1.7 本章小结

## 第二部分 自动内存管理

#### 2.1 概述

#### 2.2 运行时数据区域

> 📌 这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。 
> ⏱ 2021-03-15 16:55:18 ^27371406-15-1460-1580

> 📌 Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧[插图]（Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 
> ⏱ 2021-03-15 17:16:00 ^27371406-15-1686-1980

> 📌 如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB），以提升对象分配时的效率。不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java堆细分的目的只是为了更好地回收内存，或者更快地分配内存 
> ⏱ 2021-03-15 17:26:47 ^27371406-15-5083-5264

> 📌 虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据 
> ⏱ 2021-03-15 17:28:33 ^27371406-15-5786-5821

> 📌 常量池表（ConstantPool Table），用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 
> ⏱ 2021-03-15 17:41:46 ^27371406-15-7488-7561

#### 2.3 HotSpot虚拟机对象探秘

#### 2.4 实战：OutOfMemoryError异常

#### 2.5 本章小结

### 第3章 垃圾收集器与内存分配策略

#### 3.1 概述

#### 3.2 对象已死？

#### 3.3 垃圾收集算法

#### 3.4 HotSpot的算法细节实现

#### 3.5 经典垃圾收集器

#### 3.6 低延迟垃圾收集器

#### 3.7 选择合适的垃圾收集器

#### 3.8 实战：内存分配与回收策略

#### 3.9 本章小结

### 第4章 虚拟机性能监控、故障处理工具

#### 4.1 概述

#### 4.2 基础故障处理工具

#### 4.3 可视化故障处理工具

#### 4.4 HotSpot虚拟机插件及工具

#### 4.5 本章小结

### 第5章 调优案例分析与实战

#### 5.1 概述

#### 5.2 案例分析

#### 5.3 实战：Eclipse运行速度调优

#### 5.4 本章小结

## 第三部分 虚拟机执行子系统

#### 6.1 概述

#### 6.2 无关性的基石

#### 6.3 Class类文件的结构

#### 6.4 字节码指令简介

#### 6.5 公有设计，私有实现

#### 6.6 Class文件结构的发展

#### 6.7 本章小结

### 第7章 虚拟机类加载机制

#### 7.1 概述

#### 7.2 类加载的时机

#### 7.3 类加载的过程

#### 7.4 类加载器

#### 7.5 Java模块化系统

#### 7.6 本章小结

### 第8章 虚拟机字节码执行引擎

#### 8.1 概述

#### 8.2 运行时栈帧结构

#### 8.3 方法调用

#### 8.4 动态类型语言支持

#### 8.5 基于栈的字节码解释执行引擎

#### 8.6 本章小结

### 第9章 类加载及执行子系统的案例与实战

#### 9.1 概述

#### 9.2 案例分析

#### 9.3 实战：自己动手实现远程执行功能

#### 9.4 本章小结

## 第四部分 程序编译与代码优化

#### 10.1 概述

#### 10.2 Javac编译器

#### 10.3 Java语法糖的味道

#### 10.4 实战：插入式注解处理器

#### 10.5 本章小结

### 第11章 后端编译与优化

#### 11.1 概述

#### 11.2 即时编译器

#### 11.3 提前编译器

#### 11.4 编译器优化技术

#### 11.5 实战：深入理解Graal编译器

#### 11.6 本章小结

## 第五部分 高效并发

#### 12.1 概述

#### 12.2 硬件的效率与一致性

#### 12.3 Java内存模型

#### 12.4 Java与线程

#### 12.5 Java与协程

#### 12.6 本章小结

### 第13章 线程安全与锁优化

#### 13.1 概述

#### 13.2 线程安全

#### 13.3 锁优化

#### 13.4 本章小结

## 附录A 在Windows系统下编译OpenJDK 6

### A.1 获取JDK源码

### A.2 系统需求

### A.3 构建编译环境

### A.4 准备依赖项

### A.5 进行编译

## 附录B 展望Java技术的未来（2013年版）

### B.1 模块化

### B.2 混合语言

### B.3 多核并行

### B.4 进一步丰富语法

### B.5 64位虚拟机

## 附录C 虚拟机字节码指令表

## 附录D 对象查询语言（OQL）简介

### D.2 FROM子句

### D.3 WHERE子句

### D.4 属性访问器

### D.5 OQL语言的BNF范式

## 附录E JDK历史版本轨迹

# 读书笔记

# 本书评论
