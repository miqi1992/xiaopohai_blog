---
doc_type: weread-highlights-reviews
bookId: "38103745"
author: 尼恩编著
cover: https://cdn.weread.qq.com/weread/cover/73/YueWen_38103745/t7_YueWen_38103745.jpg
reviewCount: 10
noteCount: 98
readingStatus: 读完
progress: 100%
totalReadDay: 17
readingTime: 16小时33分钟
readingDate: 2023-05-07
finishedDate: 2023-05-20
isbn: 9787111679882
lastReadDate: 2023-07-04

---
# 元数据
> [!abstract] Java高并发核心编程（卷2）：多线程、锁、JMM、JUC、高并发设计模式
> - ![ Java高并发核心编程（卷2）：多线程、锁、JMM、JUC、高并发设计模式|200](https://cdn.weread.qq.com/weread/cover/73/YueWen_38103745/t7_YueWen_38103745.jpg)
> - 书名： Java高并发核心编程（卷2）：多线程、锁、JMM、JUC、高并发设计模式
> - 作者： 尼恩编著
> - 简介： 本书聚焦Java高并发编程基础知识，介-绍Java多线程、线程池、内置锁、JMM、CAS、JUC、高并发设计模式等并发编程方面的核心原理和实战知识。本书共10章。第1、2章剖析多线程、线程池的核心原理和实战应用，揭秘线程安全问题和Java内置锁的核心原理。第3、4章讲解CAS原理与JUC原子类、JMM的核心原理，揭秘CAS操作的弊端和两类规避措施，以及Java内存可见性和volatile关键字的底层知识。第5章讲解JUC显式锁的原理和各种显式锁的使用。第6章阐述JUC高并发的基础设施——AQS抽象同步器的核心原理。第7章介绍JUC容器类。第8~10章介绍常见的Java高并发设计模式的原理和使用。本书既可以作为Java工程师、架构师的编程参考书，又可以作为参加互联网大厂面试、笔试的人员的学习参考书。
> - 出版时间 2021-05-01 00:00:00
> - ISBN： 9787111679882
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/9b93254072456ac19b9a176

# 高亮划线

## 封面

## 版权信息

## 前言

## 自序

## 第1章 多线程原理与实战

### 1.1 两个技术面试故事

### 1.2 无处不在的进程和线程

> 📌 什么是进程呢？简单来说，进程是程序的一次启动执行。什么是程序呢？程序是存放在硬盘中的可执行文件，主要包括代码指令和数据。一个进程是一个程序的一次启动和执行，是操作系统将程序装入内存，给程序分配必要的系统资源，并且开始运行程序的指令。 
> ⏱ 2023-05-09 23:28:11 ^38103745-7-1358-1474

#### 1.2.1 进程的基本原理

> 📌 Java编写的程序都运行在Java虚拟机（JVM）中，每当使用Java命令启动一个Java应用程序时，就会启动一个JVM进程。在这个JVM进程内部，所有Java程序代码都是以线程来运行的。JVM找到程序的入口点main()方法，然后运行main()方法，这样就产生了一个线程，这个线程被称为主线程。当main()方法结束后，主线程运行完成，JVM进程也随即退出。 
> ⏱ 2023-05-09 23:25:45 ^38103745-8-1643-1824

#### 1.2.2 线程的基本原理

> 📌 线程是指“进程代码段”的一次顺序执行流程。线程是CPU调度的最小单位 
> ⏱ 2023-06-28 10:02:58 ^38103745-9-586-620

#### 1.2.3 进程与线程的区别

### 1.3 创建线程的4种方法

> 📌 虽然一个进程有很多个线程，但是在一个CPU内核上，同一时刻只能有一个线程是正在执行的，该线程也被叫作当前线程。 
> ⏱ 2023-05-20 13:24:05 ^38103745-11-635-690

#### 1.3.1 Thread类详解

> 📌 Java线程的最大优先级值为10，最小值为1，默认值为5。 
> ⏱ 2023-05-20 13:30:20 ^38103745-12-1953-1982

> 📌 start()，用来启动一个线程，当调用start()方法后，JVM才会开启一个新的线程来执行用户定义的线程代码逻辑，在这个过程中会为相应的线程分配需要的资源。 
> ⏱ 2023-07-04 00:26:14 ^38103745-12-3628-3708

> 📌 run()方法不是由用户程序来调用的，当调用start()方法启动一个线程之后，只要线程获得了CPU执行时间，便进入run()方法体去执行具体的用户线程代码。 
> ⏱ 2023-05-20 13:33:36 ^38103745-12-3797-3876

#### 1.3.2 创建一个空线程

#### 1.3.3 线程创建方法一：继承Thread类创建线程类

#### 1.3.4 线程创建方法二：实现Runnable接口创建线程目标类

> 📌 当Runnable实例传入Thread实例的target属性后，Runnable接口的run()的实现版本将被异步调用 
> ⏱ 2023-07-04 10:10:29 ^38103745-15-2014-2073

> 📌 创建线程的第二种方法就是实现Runnable接口，将需要异步执行的业务逻辑代码放在Runnable实现类的run()方法中，将Runnable实例作为target执行目标传入Thread实例 
> ⏱ 2023-07-04 10:11:32 ^38103745-15-2174-2269

#### 1.3.5 优雅创建Runnable线程目标类的两种方式

> 📌 （1）通过匿名类优雅地创建Runnable线程目标类。
（2）使用Lambda表达式优雅地创建Runnable线程目标类。 
> ⏱ 2023-05-20 13:56:49 ^38103745-16-472-604

> 📌 @FunctionalInterface注解不是必需的，只要一个接口符合“函数式接口”的定义，使用时加不加@FunctionalInterface注解都没有影响，都可以当作“函数式接口”来使用。 
> ⏱ 2023-07-04 10:19:47 ^38103745-16-2450-2547

#### 1.3.6 通过实现Runnable接口的方式创建线程目标类的优缺点

> 📌 通过实现Runnable接口的方式创建线程目标类有以下缺点：（1）所创建的类并不是线程类，而是线程的target执行目标类，需要将其实例作为参数传入线程类的构造器，才能创建真正的线程。（2）如果访问当前线程的属性（甚至控制当前线程），不能直接访问Thread的实例方法，必须通过Thread.currentThread()获取当前线程实例，才能访问和控制当前线程。通过实现Runnable接口的方式创建线程目标类有以下优点：（1）可以避免由于Java单继承带来的局限性。如果异步逻辑所在类已经继承了一个基类，就没有办法再继承Thread类。比如，当一个Dog类继承了Pet类，再要继承Thread类就不行了。所以在已经存在继承关系的情况下，只能使用实现Runnable接口的方式。（2）逻辑和数据更好分离。通过实现Runnable接口的方法创建多线程更加适合同一个资源被多段业务逻辑并行处理的场景。在同一个资源被多个线程逻辑异步、并行处理的场景中，通过实现Runnable接口的方式设计多个target执行目标类可以更加方便、清晰地将执行逻辑和数据存储分离，更好地体现了面向对象的设计思想。 
> ⏱ 2023-07-04 10:25:14 ^38103745-17-400-1025

> 📌 通过实现Runnable接口的方式创建线程目标类更加适合多个线程的代码逻辑去共享计算和处理同一个资源的场景 
> ⏱ 2023-05-09 13:50:42 ^38103745-17-1122-1175

> 📌 （1）通过继承Thread类实现多线程能更好地做到多个线程并发地完成各自的任务，访问各自的数据资源。（2）通过实现Runnable接口实现多线程能更好地做到多个线程并发地完成同一个任务，访问同一份数据资源。多个线程的代码逻辑可以方便地访问和处理同一个共享数据资源（如例子中的MallGoods.goodsAmount），这样可以将线程逻辑和业务数据进行有效的分离，更好地体现了面向对象的设计思想。（3）通过实现Runnable接口实现多线程时，如果数据资源存在多线程共享的情况，那么数据共享资源需要使用原子类型（而不是普通数据类型），或者需要进行线程的同步控制，以保证对共享数据操作时不会出现线程安全问题。总之，在大多数情况下，偏向于通过实现Runnable接口来实现线程执行目标类，这样能使代码更加简洁明了。后面介绍线程池的时候会讲到，异步执行任务在大多数情况下是通过线程池去提交的，而很少通过创建一个新的线程去提交，所以更多的做法是，通过实现Runnable接口创建异步执行任务，而不是继承Thread去创建异步执行任务。 
> ⏱ 2023-05-09 13:54:00 ^38103745-17-6632-7173

#### 1.3.7 线程创建方法三：使用Callable和FutureTask创建线程

> 📌 Callable接口实例没有办法作为Thread线程实例的target来使用。既然如此，那么该如何使用Callable接口创建线程呢？一个在Callable接口与Thread线程之间起到搭桥作用的重要接口马上就要登场了。 
> ⏱ 2023-05-20 14:35:23 ^38103745-18-1454-1564

> 📌 总体来说，Future是一个对异步任务进行交互、操作的接口。但是Future仅仅是一个接口，通过它没有办法直接完成对异步任务的操作，JDK提供了一个默认的实现类——FutureTask。 
> ⏱ 2023-05-20 14:37:29 ^38103745-18-3809-3902

> 📌 FutureTask类是Future接口的实现类，提供了对异步任务的操作的具体实现。但是，FutureTask类不仅实现了Future接口，还实现了Runnable接口，或者更加准确地说，FutureTask类实现了RunnableFuture接口 
> ⏱ 2023-05-20 14:38:55 ^38103745-18-3994-4118

> 📌 FutureTask。所以说，FutureTask类才是真正的在Thread与Callable之间搭桥的类 
> ⏱ 2023-05-20 14:38:47 ^38103745-18-4292-4345

> 📌 FutureTask的outcome实例属性用于保存callable成员call()方法的异步执行结果。在FutureTask类的run()方法完成callable成员的call()方法的执行之后，其结果将被保存在outcome实例属性中，供FutureTask类的get()方法获取。 
> ⏱ 2023-05-20 14:42:54 ^38103745-18-5366-5509

> 📌 returnableThread线程首先执行的是thread.run()方法，然后在其中会执行到其target（futureTask任务）的run()方法；接着在这个futureTask.run()方法中会执行futureTask的callable成员的call()方法，这里的callable成员（ReturnableTask实例）是通过FutureTask构造器在初始化时传递进来的、自定义的Callable实现类的实例。 
> ⏱ 2023-05-09 14:08:16 ^38103745-18-8919-9132

#### 1.3.8 线程创建方法四：通过线程池创建线程

> 📌 ExecutorService线程池的execute(...)与submit(...)方法的区别如下。（1）接收的参数不一样submit()可以接收两种入参：无返回值的Runnable类型的target执行目标实例和有返回值的Callable类型的target执行目标实例。而execute()仅仅接收无返回值的target执行目标实例，或者无返回值的Thread实例。（2）submit()有返回值，而execute()没有submit()方法在提交异步target执行目标之后会返回Future异步任务实例，以便对target的异步执行过程进行控制，比如取消执行、获取结果等。execute()没有任何返回，target执行目标实例在执行之后没有办法对其异步执行过程进行控制，只能任其执行，直到其执行结束。 
> ⏱ 2023-05-10 10:15:42 ^38103745-19-5079-5540

### 1.4 线程的核心原理

#### 1.4.1 线程的调度与时间片

#### 1.4.2 线程的优先级

#### 1.4.3 线程的生命周期

> 📌  NEW（新建）状态、RUNNABLE（可执行）状态、TERMINATED（终止）状态、TIMED_WAITING（限时等待）状态 ^38103745-23-1183-1247
- 💭 线程的状态：NEW(新建)、RUNNABLE(可执行)、TERMINATED(终止)、TIMED_WAITING(限时等待)、WAITING(等待)、BLOCKED(阻塞) - ⏱ 2023-05-10 10:20:56 

> 📌 TIMED_WAITING状态线程处于一种特殊的等待状态，准确地说，线程处于限时等待状态。能让线程处于限时等待状态的操作大致有以下几种：（1）Thread.sleep(int n)：使得当前线程进入限时等待状态，等待时间为n毫秒。（2）Object.wait()：带时限的抢占对象的monitor锁。（3）Thread.join()：带时限的线程合并。（4）LockSupport.parkNanos()：让线程等待，时间以纳秒为单位。（5）LockSupport.parkUntil()：让线程等待，时间可以灵活设置。 
> ⏱ 2023-05-10 11:06:54 ^38103745-23-3122-3545

#### 1.4.4 一个线程状态的简单演示案例

#### 1.4.5 使用Jstack工具查看线程状态

### 1.5 线程的基本操作

#### 1.5.1 线程名称的设置和获取

#### 1.5.2 线程的sleep操作

#### 1.5.3 线程的interrupt操作

> 📌 如果线程被Object.wait()、Thread.join()和Thread.sleep()三种方法之一阻塞，此时调用该线程的interrupt()方法，该线程将抛出一个InterruptedException中断异常（该线程必须事先预备好处理此异常），从而提早终结被阻塞状态。 
> ⏱ 2023-05-10 11:38:36 ^38103745-29-958-1098

> 📌 如果此线程正处于运行之中，线程就不受任何影响，继续运行，仅仅是线程的中断标记被设置为true。所以，程序可以在适当的位置通过调用isInterrupted()方法来查看自己是否被中断，并执行退出操作。 
> ⏱ 2023-05-10 11:38:57 ^38103745-29-1127-1227

> 📌  如果线程的interrupt()方法先被调用，然后线程开始调用阻塞方法进入阻塞状态，InterruptedException异常依旧会抛出 ^38103745-29-1280-1349
- 💭 抛出异常之后，中断状态被清空
而LockSupport.park()则不会清空，需要手动调用Thread.interrupted() - ⏱ 2023-05-10 11:39:18 

> 📌  如果线程捕获InterruptedException异常后，继续调用阻塞方法，将不再触发InterruptedException异常。 ^38103745-29-1350-1417
- 💭 作者说的意思是这次阻塞捕捉之后，如果再次阻塞，依然会被阻塞(这是因为中断状态会被清空) - ⏱ 2023-05-20 16:46:08 

> 📌  线程捕获InterruptedException异常后，继续调用阻塞方法，将不再触发InterruptedException异常 ^38103745-29-1352-1416
- 💭 这里有点歧义 - ⏱ 2023-05-20 16:44:26 

> 📌 Thread.interrupt()方法并不像Thread.stop()方法那样中止一个正在运行的线程，其作用是设置线程的中断状态位（为true），至于线程是死亡、等待新的任务还是继续运行至下一步，就取决于这个程序本身。线程可以不时地检测这个中断标示位，以判断线程是否应该被中断（中断标示值是否为true）。总之，Thread.interrupt()方法只是改变中断状态，不会中断一个正在运行的线程，线程是否停止执行，需要用户程序去监视线程的isInterrupted()状态，并进行相应的处理。 
> ⏱ 2023-05-10 11:48:35 ^38103745-29-3945-4193

#### 1.5.4 线程的join操作

> 📌 join()方法是实例方法，需要使用被合并线程的句柄（或者指针、变量）去调用 
> ⏱ 2023-05-10 11:51:26 ^38103745-30-1472-1510

> 📌 本书将依赖的线程A叫作甲方线程，被依赖的线程B叫作乙方线程。简单理解线程合并就是甲方线程调用乙方线程的join()方法，在执行流程上将乙方线程合并到甲方线程。甲方线程等待乙方线程执行完成后，甲方线程再继续执行 
> ⏱ 2023-05-10 11:51:54 ^38103745-30-1909-2013

#### 1.5.5 线程的yield操作

#### 1.5.6 线程的daemon操作

> 📌 只要JVM实例中尚存在任何一个用户线程没有结束，守护线程就能执行自己的工作；只有当最后一个用户线程结束，守护线程随着JVM一同结束工作 
> ⏱ 2023-05-20 16:04:04 ^38103745-32-1376-1443

#### 1.5.7 线程状态总结

### 1.6 线程池原理与实战

#### 1.6.1 JUC的线程池架构

> 📌 在JUC中有关线程池的类与接口的架构图大致如图1-15所示。
￼
图1-15　JUC中线程池的类与接口的架构 
> ⏱ 2023-05-20 17:34:38 ^38103745-35-519-790

#### 1.6.2 Executors的4种快捷创建线程池的方法

#### 1.6.3 线程池的标准创建方式

#### 1.6.4 向线程池提交任务的两种方式

> 📌 Runnable和Callable的主要区别为：Callable允许有返回值，Runnable不允许有返回值；Runnable不允许抛出异常，Callable允许抛出异常 
> ⏱ 2023-05-20 17:27:31 ^38103745-38-1171-1256

#### 1.6.5 线程池的任务调度流程

> 📌 总体的线程池的任务调度流程如图1-16所示。
￼
图1-16　总体的线程池的任务调度流程 
> ⏱ 2023-05-20 17:30:34 ^38103745-39-984-1245

#### 1.6.6 ThreadFactory（线程工厂）

> 📌 Executors为线程池工厂类，用于快捷创建线程池（Thread Pool）；ThreadFactory为线程工厂类，用于创建线程（Thread） 
> ⏱ 2023-05-09 15:18:23 ^38103745-40-1085-1159

#### 1.6.7 任务阻塞队列

> 📌  暂时 ^38103745-41-573-575
- 💭 应该是暂存吧 - ⏱ 2023-05-20 17:39:35 

#### 1.6.8 调度器的钩子方法

#### 1.6.9 线程池的拒绝策略

> 📌 无论以上哪种情况任务被拒绝，线程池都会调用RejectedExecutionHandler实例的rejectedExecution方法。RejectedExecutionHandler是拒绝策略的接口，JUC为该接口提供了以下几种实现：
·AbortPolicy：拒绝策略。
·DiscardPolicy：抛弃策略。
·DiscardOldestPolicy：抛弃最老任务策略。
·CallerRunsPolicy：调用者执行策略。
·自定义策略。 
> ⏱ 2023-05-20 22:56:14 ^38103745-43-568-922

> 📌 线程池默认的拒绝策略为AbortPolicy，如果提交的任务被拒绝，线程池就会抛出RejectedExecutionException异常，该异常是非受检异常（运行时异常），很容易忘记捕获。 
> ⏱ 2023-05-20 23:00:57 ^38103745-43-1837-1932

#### 1.6.10 线程池的优雅关闭

> 📌 如果使用了线程池，可以在JVM中注册一个钩子函数，在JVM进程关闭之前，由钩子函数自动将线程池优雅地关闭，以确保资源正常释放。 
> ⏱ 2023-05-20 23:13:59 ^38103745-44-9156-9219

#### 1.6.11 Executors快捷创建线程池的潜在问题

### 1.7 确定线程池的线程数

> 📌 使用线程池的好处主要有以下三点： 
> ⏱ 2023-05-20 23:24:09 ^38103745-46-379-395

#### 1.7.1 按照任务类型对线程池进行分类

#### 1.7.2 为IO密集型任务确定线程数

#### 1.7.3 为CPU密集型任务确定线程数

> 📌 CPU密集型任务并行执行的数量应当等于CPU的核心数。 
> ⏱ 2023-05-20 23:32:38 ^38103745-49-513-540

#### 1.7.4 为混合型任务确定线程数

### 1.8 ThreadLocal原理与实战

#### 1.8.1 ThreadLocal的基本使用

#### 1.8.2 ThreadLocal的使用场景

> 📌 ThreadLocal保存函数之间需要传递的数据，在需要的地方直接获取，也能避免通过参数传递数据带来的高耦合。 
> ⏱ 2023-06-25 00:24:24 ^38103745-53-1334-1389

#### 1.8.3 使用ThreadLocal进行线程隔离

#### 1.8.4 使用ThreadLocal进行跨函数数据传递

#### 1.8.5 ThreadLocal内部结构演进

#### 1.8.6 ThreadLocal源码分析

#### 1.8.7 ThreadLocalMap源码分析

#### 1.8.8 ThreadLocal综合使用案例

## 第2章 Java内置锁的核心原理

> 📌 Java内置锁是一个互斥锁 
> ⏱ 2023-05-21 12:55:33 ^38103745-60-382-395

> 📌 获得内置锁的唯一途径就是进入这个锁保护的同步代码块或方法。 
> ⏱ 2023-05-21 12:57:56 ^38103745-60-574-603

### 2.1 线程安全问题

#### 2.1.1 自增运算不是线程安全的

#### 2.1.2 临界区资源与临界区代码段

> 📌 临界区资源表示一种可以被多个线程使用的公共资源或共享数据，但是每一次只能有一个线程使用它 
> ⏱ 2023-05-21 13:04:33 ^38103745-63-609-653

> 📌 临界区代码段（Critical Section）是每个线程中访问临界资源的那段代码 
> ⏱ 2023-05-21 13:05:25 ^38103745-63-728-769

> 📌 竞态条件（Race Conditions）可能是由于在访问临界区代码段时没有互斥地访问而导致的特殊情况。 
> ⏱ 2023-05-21 13:06:56 ^38103745-63-1125-1177

### 2.2 synchronized关键字

#### 2.2.1 synchronized同步方法

#### 2.2.2 synchronized同步块

> 📌 由于每一个Java对象都有一把监视锁，因此任何Java对象都能作为synchronized的同步锁 
> ⏱ 2023-05-21 13:22:46 ^38103745-66-1472-1521

> 📌 synchronized方法和synchronized代码块有什么联系呢？在Java的内部实现上，synchronized方法实际上等同于用一个synchronized代码块，这个代码块包含同步方法中的所有语句，然后在synchronized代码块的括号中传入this关键字，使用this对象锁作为进入临界区的同步锁。 
> ⏱ 2023-05-21 23:55:37 ^38103745-66-2857-3016

> 📌 synchronized方法的同步锁实质上使用了this对象锁，这样就免去了手工设置同步锁的工作。而使用synchronized代码块需要手工设置同步锁。 
> ⏱ 2023-05-21 13:25:07 ^38103745-66-3518-3595

#### 2.2.3 静态的同步方法

> 📌 所有的类都是在第一次使用时被动态加载到JVM中的（懒加载），其各个类都是在必需时才加载的。这一点与许多传统语言（如C++）都不同，JVM为动态加载机 
> ⏱ 2023-05-21 23:58:19 ^38103745-67-660-734

> 📌 synchronized的同步锁并不是普通Object对象的监视锁，而是类所对应的Class对象的监视锁。 
> ⏱ 2023-05-21 23:58:53 ^38103745-67-1628-1681

> 📌 这里将Object对象的监视锁叫作对象锁，将Class对象的监视锁叫作类锁。当synchronized关键字修饰static方法时，同步锁为类锁；当synchronized关键字修饰普通的成员方法（非静态方法）时，同步锁为类锁 
> ⏱ 2023-05-21 23:59:12 ^38103745-67-1714-1827

> 📌 通过synchronized关键字所抢占的同步锁什么时候释放呢？一种场景是synchronized块（代码块或者方法）正确执行完毕，监视锁自动释放；另一种场景是程序出现异常，非正常退出synchronized块，监视锁也会自动释放。所以，使用synchronized块时不必担心监视锁的释放问题。 
> ⏱ 2023-05-21 23:59:42 ^38103745-67-2144-2292

### 2.3 生产者-消费者问题

#### 2.3.1 生产者-消费者模式

#### 2.3.2 一个线程不安全的实现版本

#### 2.3.3 一个线程安全的实现版本

### 2.4 Java对象结构与内置锁

#### 2.4.1 Java对象结构

> 📌 对于对象指针而言，如果JVM中的对象数量过多，使用64位的指针将浪费大量内存，通过简单统计，64位JVM将会比32位JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩。UseCompressedOops中的Oop为Ordinary object pointer（普通对象指针）的缩写。 
> ⏱ 2023-05-22 00:03:15 ^38103745-73-2403-2569

#### 2.4.2 Mark Word的结构信息

> 📌 Mark Word的位长度不会受到Oop对象指针压缩选项的影响。 
> ⏱ 2023-05-22 00:04:35 ^38103745-74-499-531

> 📌 调用Object.hashCode()方法或者System.identityHashCode()方法计算对象的HashCode后，其结果将被写到该对象头中。当对象被锁定时，该值会移动到Monitor（监视器）中。 
> ⏱ 2023-05-22 00:07:40 ^38103745-74-2544-2650

#### 2.4.3 使用JOL工具查看对象的布局

> 📌 对象一旦生成了哈希码，JVM会将其记录在对象头的Mark Word中。当然，只有调用未重写的Object.hashcode()方法，或者调用System.IdentityHashCode(obj)方法时，其值才被记录到Mark Word中。如果调用的是重写的hashcode()方法，也不会记录到Mark Word中。 
> ⏱ 2023-05-21 14:22:57 ^38103745-75-6509-6668

#### 2.4.4 大小端问题

#### 2.4.5 无锁、偏向锁、轻量级锁和重量级锁

### 2.5 偏向锁的原理与实战

#### 2.5.1 偏向锁的核心原理

> 📌 一旦有第二条线程需要竞争锁，那么偏向模式立即结束，进入轻量级锁的状态。 
> ⏱ 2023-05-21 14:47:44 ^38103745-79-816-851

#### 2.5.2 偏向锁的演示案例

> 📌 { ​​​​​            for (int i = 0; i < MAX_TURN; i++) ​​​​​            { ​​​​​                synchronized (lock) ​​​​​                { ​​​​​                    lock.increase(); ​​​​​                    if (i == MAX_TURN / 2) ​​​​​                    { ​​​​​                        Print.tcfo("占有锁, lock的状态: "); ​​​​​                        lock.printObjectStruct(); ​​​​​                    } ​​​​​                } ​​​​​                //每一次循环等待10毫秒 ​​​​​                sleepMilliSeconds(10); ​​​​​            } ​​​​​            latch.countDown(); ​​​​​        }; ​​​​​        new Thread(runnable, "biased-demo-thread").start(); ​​​​​        //等待加锁线程执行完成 ​​​​​        latch.await(); ​​​​​        sleepMilliSeconds(5000); ​​​​​        Print.tcfo("释放锁后, lock的状态: "); ​​​​​        lock.printObjectStruct(); ​​​​​    } ​​​​​  // 省略不相干代码 ​​​​​}​​

2.偏向锁演示案例运行过程说明 
> ⏱ 2023-05-21 20:07:40 ^38103745-80-1196

#### 2.5.3 偏向锁的膨胀和撤销

### 2.6 轻量级锁的原理与实战

#### 2.6.1 轻量级锁的核心原理

#### 2.6.2 轻量级锁的演示案例

#### 2.6.3 轻量级锁的分类

#### 2.6.4 轻量级锁的膨胀

### 2.7 重量级锁的原理与实战

#### 2.7.1 重量级锁的核心原理

#### 2.7.2 重量级锁的开销

#### 2.7.3 重量级锁的演示案例

### 2.8 偏向锁、轻量级锁与重量级锁的对比

### 2.9 线程间通信

#### 2.9.1 线程间通信的定义

#### 2.9.2 低效的线程轮询

#### 2.9.3 wait方法和notify方法的原理

> 📌 locko.notify()调用后，唤醒locko监视器等待集中的第一条等待线程；被唤醒的线程进入EntryList，其状态从WAITING变成BLOCKED 
> ⏱ 2023-05-21 21:02:49 ^38103745-95-2488-2567

#### 2.9.4 “等待-通知”通信模式演示案例

#### 2.9.5 生产者-消费者之间的线程间通信

#### 2.9.6 需要在synchronized同步块的内部使用wait和notify

## 第3章 CAS原理与JUC原子类

> 📌 CAS是CPU指令级的原子操作，并处于用户态下，所以JVM轻量级锁的开销较小。 
> ⏱ 2023-05-21 23:07:11 ^38103745-99-529-568

### 3.1 什么是CAS

#### 3.1.1 Unsafe类中的CAS方法

> 📌 操作系统层面的CAS是一条CPU的原子指令（cmpxchg指令），正是由于该指令具备原子性，因此使用CAS操作数据时不会造成数据不一致的问题，Unsafe提供的CAS方法直接通过native方式（封装C++代码）调用了底层的CPU指令cmpxchg。 
> ⏱ 2023-05-21 23:09:32 ^38103745-101-867-992

> 📌 Unsafe的CAS操作会将第一个参数（对象的指针、地址）与第二个参数（字段偏移量）组合在一起，计算出最终的内存操作地址。 
> ⏱ 2023-05-21 23:14:23 ^38103745-101-3446-3507

#### 3.1.2 使用CAS进行无锁编程

> 📌 重复俗称CAS自旋 
> ⏱ 2023-05-21 23:20:21 ^38103745-102-700-709

> 📌 当并发修改的线程少，冲突出现的机会少时，自旋的次数也会很少，CAS的性能会很高；当并发修改的线程多，冲突出现的机会多时，自旋的次数也会很多，CAS的性能会大大降低。所以，提升CAS无锁编程效率的关键在于减少冲突的机会。 
> ⏱ 2023-05-21 23:22:04 ^38103745-102-2148-2257

#### 3.1.3 使用无锁编程实现轻量级安全自增

#### 3.1.4 字段偏移量的计算

### 3.2 JUC原子类

> 📌 synchronized同步机制相比，JDK原子类是基于CAS轻量级原子操作的实现，使得程序运行效率变得更高。 
> ⏱ 2023-05-22 22:50:58 ^38103745-105-501-556

#### 3.2.1 JUC中的Atomic原子操作包

> 📌 AtomicMarkableReference类将boolean标记与引用关联起来，可以解决使用AtomicBoolean进行原子更新时可能出现的ABA问题。 
> ⏱ 2023-05-22 22:54:32 ^38103745-106-1765-1844

> 📌 AtomicStampedReference类将整数值与引用关联起来，可以解决使用AtomicInteger进行原子更新时可能出现的ABA问题。 
> ⏱ 2023-05-22 22:55:22 ^38103745-106-1870-1942

#### 3.2.2 基础原子类AtomicInteger

#### 3.2.3 数组原子类AtomicIntegerArray

#### 3.2.4 AtomicInteger线程安全原理

> 📌 基础原子类（以AtomicInteger为例）主要通过CAS自旋+volatile的方案实现， 
> ⏱ 2023-05-22 23:03:20 ^38103745-109-391-438

> 📌 关键字volatile的原理比较复杂，简单地说，该关键字可以保证任何线程在任何时刻总能拿到该变量的最新值，其目的在于保障变量值的线程可见性。 
> ⏱ 2023-05-22 23:06:55 ^38103745-109-3737-3807

### 3.3 对象操作的原子性

> 📌 如果需要同时保障对多个变量操作的原子性，就可以把多个变量放在一个对象中进行操作 
> ⏱ 2023-05-22 23:07:53 ^38103745-110-496-535

#### 3.3.1 引用类型原子类

> 📌 使用原子引用类型AtomicReference包装了User对象之后，只能保障User引用的原子操作，对被包装的User对象的字段值修改时不能保证原子性，这点要切记 
> ⏱ 2023-05-22 23:11:50 ^38103745-111-2896-2978

#### 3.3.2 属性更新原子类

> 📌 第一步，更新的对象属性必须使用public volatile修饰符 
> ⏱ 2023-05-22 23:13:00 ^38103745-112-803-836

> 📌 第二步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须调用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。 
> ⏱ 2023-05-22 23:14:23 ^38103745-112-865-940

### 3.4 ABA问题

#### 3.4.1 了解ABA问题

#### 3.4.2 ABA问题解决方案

#### 3.4.3 使用AtomicStampedReference解决ABA问题

> 📌 AtomicStampReference在CAS的基础上增加了一个Stamp（印戳或标记），使用这个印戳可以用来觉察数据是否发生变化，给数据带上了一种实效性的检验 
> ⏱ 2023-05-22 23:19:02 ^38103745-116-453-534

#### 3.4.4 使用AtomicMarkableReference解决ABA问题

> 📌 AtomicMarkableReference是AtomicStampedReference的简化版，不关心修改过几次，只关心是否修改过。因此，其标记属性mark是boolean类型，而不是数字类型，标记属性mark仅记录值是否修改过。
AtomicMarkableReference适用于只要知道对象是否被修改过，而不适用于对象被反复修改的场景 
> ⏱ 2023-05-22 23:22:28 ^38103745-117-404-602

### 3.5 提升高并发场景下CAS操作的性能

#### 3.5.1 以空间换时间：LongAdder

> 📌 LongAdder的核心思想是热点分离，与ConcurrentHashMap的设计思想类似：将value值分离成一个数组，当多线程访问时，通过Hash算法将线程映射到数组的一个元素进行操作；而获取最终的value结果时，则将数组的元素求和。 
> ⏱ 2023-05-22 23:24:57 ^38103745-119-464-584

#### 3.5.2 LongAdder的原理

> 📌 LongAdder的基本思路是分散热点，将value值分散到一个数组中，不同线程会命中到数组的不同槽（元素）中，各个线程只对自己槽中的那个值进行CAS操作。这样热点就被分散了，冲突的概率就小很多。 
> ⏱ 2023-05-22 23:29:26 ^38103745-120-543-641

### 3.6 CAS在JDK中的广泛应用

#### 3.6.1 CAS操作的弊端和规避措施

#### 3.6.2 CAS操作在JDK中的应用

## 第4章 可见性与有序性的原理

> 📌 原子性、可见性、有序性是并发编程所面临的三大问题。 
> ⏱ 2023-05-22 23:36:32 ^38103745-124-380-405

### 4.1 CPU物理缓存结构

> 📌 CPU和主存之间设计了多层的Cache（高速缓存），越靠近CPU的高速缓存越快，容量也越小。 
> ⏱ 2023-05-22 23:39:06 ^38103745-125-435-481

> 📌 CPU内核读取数据时，先从L1高速缓存中读取，如果没有命中，再到L2、L3高速缓存中读取，假如这些高速缓存都没有命中，它就会到主存中读取所需要的数据。 
> ⏱ 2023-05-23 22:33:31 ^38103745-125-1261-1336

### 4.2 并发编程的三大问题

> 📌 原子性问题、可见性问题和有序性问题。 
> ⏱ 2023-05-23 01:10:47 ^38103745-126-537-555

#### 4.2.1 原子性问题

> 📌 所谓原子操作，就是“不可中断的一个或一系列操作”，是指不会被线程调度机制打断的操作。这种操作一旦开始，就一直运行到结束，中间不会有任何线程的切换。
下面来看一小段程序： 
> ⏱ 2023-05-23 01:11:07 ^38103745-127-377-486

#### 4.2.2 可见性问题

> 📌 JMM规定，将所有的变量都存放在公共主存中，当线程使用变量时会把主存中的变量复制到自己的工作空间（或者叫私有内存）中，线程对变量的读写操作，是自己工作内存中的变量副本。 
> ⏱ 2023-05-23 01:13:36 ^38103745-128-491-575

#### 4.2.3 有序性问题

> 📌 所谓程序的有序性，是指程序按照代码的先后顺序执行。如果程序执行的顺序与代码的先后顺序不同，并导致了错误的结果，即发生了有序性问题。 
> ⏱ 2023-05-23 01:17:52 ^38103745-129-377-442

> 📌 。一般来说，CPU为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行顺序同代码中的先后顺序一致，但是它会保证程序最终的执行结果和代码顺序执行的结果是一致的。 
> ⏱ 2023-05-23 01:19:01 ^38103745-129-2689-2780

> 📌 指令重排序不会影响单个线程的执行，但是会影响多个线程并发执行的正确性 
> ⏱ 2023-05-23 01:19:59 ^38103745-129-3152-3186

### 4.3 硬件层的MESI协议原理

> 📌 每个CPU内核都只有自己的一级、二级高速缓存，CPU芯片板上的CPU内核之间共享一个三级高速缓存。 
> ⏱ 2023-05-24 22:56:48 ^38103745-130-421-470

> 📌 在CPU进行计算时，直接从高速缓存中读取数据并且在计算完成之后写回高速缓存中。在整个运算过程完成后，再把高速缓存中的数据同步到主存。 
> ⏱ 2023-05-24 22:56:56 ^38103745-130-532-598

> 📌 硬件层的MESI协议是一种用于解决内存的可见性问题的手段， 
> ⏱ 2023-05-24 08:19:30 ^38103745-130-754-783

#### 4.3.1 总线锁和缓存锁

> 📌 总线锁的缺陷是：某一个CPU访问主存时，总线锁把CPU和主存的通信给锁住了，其他CPU不能操作其他主存地址的数据，使得效率低下，开销较大。 
> ⏱ 2023-05-23 01:23:56 ^38103745-131-1396-1465

> 📌 在多CPU的系统中，为了保证各个CPU的高速缓存中数据的一致性，会实现缓存一致性协议，每个CPU通过嗅探在总线上传播的数据来检查自己的高速缓存中的值是否过期，当CPU发现自己缓存行对应的主存地址被修改时，就会将当前CPU的缓存行设置成无效状态，当CPU对这个数据执行修改操作时，会重新从系统主存中把数据读到CPU的高速缓存中。 
> ⏱ 2023-05-24 23:05:40 ^38103745-131-2374-2537

#### 4.3.2 MSI协议

#### 4.3.3 MESI协议及RFO请求

#### 4.3.4 volatile的原理

> 📌 正常情况下，系统操作并不会校验共享变量的缓存一致性，只有当共享变量用volatile关键字修饰了，该变量所在的缓存行才被要求进行缓存一致性的校验。 
> ⏱ 2023-05-25 07:08:30 ^38103745-134-488-561

### 4.4 有序性与内存屏障

#### 4.4.1 重排序

> 📌 重排序主要分为两类：编译器重排序和CPU重排序 
> ⏱ 2023-05-25 07:16:53 ^38103745-136-401-424

#### 4.4.2 As-if-Serial规则

> 📌 As-if-Serial规则只能保障单内核指令重排序之后的执行结果正确，不能保障多内核以及跨CPU指令重排序之后的执行结果正确。 
> ⏱ 2023-05-25 07:22:12 ^38103745-137-2235-2299

#### 4.4.3 硬件层面的内存屏障

### 4.5 JMM详解

#### 4.5.1 什么是Java内存模型

#### 4.5.2 JMM与JVM物理内存的区别

> 📌 JMM属于语言级别的内存模型，它确保了在不同的编译器和不同的CPU平台上为Java程序员提供一致的内存可见性保证和指令并发执行的有序性。 
> ⏱ 2023-05-25 07:33:34 ^38103745-141-477-545

#### 4.5.3 JMM的8个操作

#### 4.5.4 JMM如何解决有序性问题

#### 4.5.5 volatile语义中的内存屏障

### 4.6 Happens-Before规则

#### 4.6.1 Happens-Before规则介绍

#### 4.6.2 规则1：顺序性规则

#### 4.6.3 规则2：volatile规则

#### 4.6.4 规则3：传递性规则

#### 4.6.5 规则4：监视锁规则

#### 4.6.6 规则5：start()规则

#### 4.6.7 规则6：join()规则

### 4.7 volatile不具备原子性

#### 4.7.1 volatile变量的自增实例

#### 4.7.2 volatile变量的复合操作不具备原子性的原理

## 第5章 JUC显式锁的原理与实战

### 5.1 显式锁

#### 5.1.1 显式锁Lock接口

#### 5.1.2 可重入锁ReentrantLock

> 📌 ReentrantLock基于内置的抽象队列同步器（Abstract Queued Synchronized，AQS）实现，在争用激烈的场景下，能表现出表内置锁更佳的性能 
> ⏱ 2023-05-24 12:53:42 ^38103745-159-501-586

#### 5.1.3 使用显式锁的模板代码

#### 5.1.4 基于显式锁进行“等待-通知”方式的线程间通信

#### 5.1.5 LockSupport

#### 5.1.6 显式锁的分类

### 5.2 悲观锁和乐观锁

#### 5.2.1 悲观锁存在的问题

#### 5.2.2 通过CAS实现乐观锁

#### 5.2.3 不可重入的自旋锁

#### 5.2.4 可重入的自旋锁

#### 5.2.5 CAS可能导致“总线风暴”

#### 5.2.6 CLH自旋锁

### 5.3 公平锁与非公平锁

#### 5.3.1 非公平锁实战

#### 5.3.2 公平锁实战

### 5.4 可中断锁与不可中断锁

#### 5.4.1 锁的可中断抢占

#### 5.4.2 死锁的监测与中断

### 5.5 共享锁与独占锁

#### 5.5.1 独占锁

#### 5.5.2 共享锁Semaphore

#### 5.5.3 共享锁CountDownLatch

### 5.6 读写锁

#### 5.6.1 读写锁ReentrantReadWriteLock

#### 5.6.2 锁的升级与降级

#### 5.6.3 StampedLock

## 第6章 AQS抽象同步器的核心原理

### 6.1 锁与队列的关系

### 6.2 AQS的核心成员

#### 6.2.1 状态标志位

#### 6.2.2 队列节点类

#### 6.2.3 FIFO双向同步队列

#### 6.2.4 JUC显式锁与AQS的关系

#### 6.2.5 ReentrantLock与AQS的组合关系

### 6.3 AQS中的模板模式

#### 6.3.1 模板模式

#### 6.3.2 一个模板模式的参考实现

#### 6.3.3 AQS的模板流程

#### 6.3.4 AQS中的钩子方法

### 6.4 通过AQS实现一把简单的独占锁

#### 6.4.1 简单的独占锁的UML类图

#### 6.4.2 简单的独占锁的实现

#### 6.4.3 SimpleMockLock测试用例

### 6.5 AQS锁抢占的原理

#### 6.5.1 显式锁抢占的总体流程

#### 6.5.2 AQS模板方法：acquire(arg)

#### 6.5.3 钩子实现：tryAcquire(arg)

#### 6.5.4 直接入队：addWaiter

#### 6.5.5 自旋入队：enq

#### 6.5.6 自旋抢占：acquireQueued()

#### 6.5.7 挂起预判：shouldParkAfterFailedAcquire()

#### 6.5.8 线程挂起：parkAndCheckInterrupt()

### 6.6 AQS的两个关键点：节点的入队和出队

#### 6.6.1 节点的自旋入队

#### 6.6.2 节点的出队

### 6.7 AQS锁释放的原理

#### 6.7.1 SimpleMockLock独占锁的释放流程

#### 6.7.2 AQS模板方法：release()

#### 6.7.3 钩子实现：tryRelease()

#### 6.7.4 唤醒后继：unparkSuccessor()

### 6.8 ReentrantLock的抢锁流程

#### 6.8.1 ReentrantLock非公平锁的抢占流程

#### 6.8.2 非公平锁的同步器子类

#### 6.8.3 非公平抢占的钩子方法：tryAcquire(arg)

#### 6.8.4 ReentrantLock公平锁的抢占流程

#### 6.8.5 公平锁的同步器子类

#### 6.8.6 公平抢占的钩子方法：tryAcquire(arg)

#### 6.8.7 是否有后继节点的判断

### 6.9 AQS条件队列

#### 6.9.1 Condition基本原理

#### 6.9.2 await()等待方法原理

#### 6.9.3 signal()唤醒方法原理

### 6.10 AQS的实际应用

## 第7章 JUC容器类

### 7.1 线程安全的同步容器类

### 7.2 JUC高并发容器

### 7.3 CopyOnWriteArrayList

#### 7.3.1 CopyOnWriteArrayList的使用

#### 7.3.2 CopyOnWriteArrayList的原理

#### 7.3.3 CopyOnWriteArrayList读取操作

#### 7.3.4 CopyOnWriteArrayList写入操作

#### 7.3.5 CopyOnWriteArrayList的迭代器实现

### 7.4 BlockingQueue

#### 7.4.1 BlockingQueue的特点

#### 7.4.2 阻塞队列的常用方法

#### 7.4.3 常见的BlockingQueue

#### 7.4.4 ArrayBlockingQueue的基本使用

#### 7.4.5 ArrayBlockingQueue构造器和成员

#### 7.4.6 非阻塞式添加元素：add()、offer()方法的原理

#### 7.4.7 阻塞式添加元素：put()方法的原理

#### 7.4.8 非阻塞式删除元素：poll()方法的原理

#### 7.4.9 阻塞式删除元素：take()方法的原理

#### 7.4.10 peek()直接返回当前队列的头元素

### 7.5 ConcurrentHashMap

#### 7.5.1 HashMap和HashTable的问题

#### 7.5.2 JDK 1.7版本ConcurrentHashMap的结构

#### 7.5.3 JDK 1.7版本ConcurrentHashMap的核心原理

#### 7.5.4 JDK 1.8版本ConcurrentHashMap的结构

#### 7.5.5 JDK 1.8版本ConcurrentHashMap的核心原理

#### 7.5.6 JDK 1.8版本ConcurrentHashMap的核心源码

## 第8章 高并发设计模式

### 8.1 线程安全的单例模式

#### 8.1.1 从饿汉式单例到懒汉式单例

#### 8.1.2 使用内置锁保护懒汉式单例

#### 8.1.3 双重检查锁单例模式

#### 8.1.4 使用双重检查锁+volatile

#### 8.1.5 使用静态内部类实现懒汉式单例模式

### 8.2 Master-Worker模式

#### 8.2.1 Master-Worker模式的参考实现

#### 8.2.2 Netty中Master-Worker模式的实现

#### 8.2.3 Nginx中Master-Worker模式的实现

### 8.3 ForkJoin模式

#### 8.3.1 ForkJoin模式的原理

#### 8.3.2 ForkJoin框架

#### 8.3.3 ForkJoin框架使用实战

#### 8.3.4 ForkJoin框架的核心API

#### 8.3.5 工作窃取算法

#### 8.3.6 ForkJoin框架的原理

### 8.4 生产者-消费者模式

### 8.5 Future模式

## 第9章 高并发核心模式之异步回调模式

### 9.1 从泡茶的案例讲起

### 9.2 join：异步阻塞之闷葫芦

#### 9.2.1 线程的合并流程

#### 9.2.2 调用join()实现异步泡茶喝

#### 9.2.3 join()方法详解

### 9.3 FutureTask：异步调用之重武器

#### 9.3.1 通过FutureTask获取异步执行结果的步骤

#### 9.3.2 使用FutureTask实现异步泡茶喝

### 9.4 异步回调与主动调用

### 9.5 Guava的异步回调模式

#### 9.5.1 详解FutureCallback

#### 9.5.2 详解ListenableFuture

#### 9.5.3 ListenableFuture异步任务

#### 9.5.4 使用Guava实现泡茶喝的实例

#### 9.5.5 Guava异步回调和Java异步调用的区别

### 9.6 Netty的异步回调模式

#### 9.6.1 GenericFutureListener接口详解

#### 9.6.2 Netty的Future接口详解

#### 9.6.3 ChannelFuture的使用

#### 9.6.4 Netty的出站和入站异步回调

### 9.7 异步回调模式小结

## 第10章 CompletableFuture异步回调

### 10.1 CompletableFuture详解

#### 10.1.1 CompletableFuture的UML类关系

#### 10.1.2 CompletionStage接口

#### 10.1.3 使用runAsync和supplyAsync创建子任务

#### 10.1.4 设置子任务回调钩子

#### 10.1.5 调用handle()方法统一处理异常和结果

#### 10.1.6 线程池的使用

### 10.2 异步任务的串行执行

#### 10.2.1 thenApply()方法

#### 10.2.2 thenRun()方法

#### 10.2.3 thenAccept()方法

#### 10.2.4 thenCompose()方法

#### 10.2.5 4个任务串行方法的区别

### 10.3 异步任务的合并执行

#### 10.3.1 thenCombine()方法

#### 10.3.2 runAfterBoth()方法

#### 10.3.3 thenAcceptBoth()方法

#### 10.3.4 allOf()等待所有的任务结束

### 10.4 异步任务的选择执行

#### 10.4.1 applyToEither()方法

#### 10.4.2 runAfterEither()方法

#### 10.4.3 acceptEither()方法

### 10.5 CompletableFuture的综合案例

#### 10.5.1 使用CompletableFuture实现泡茶喝实例

#### 10.5.2 使用CompletableFuture进行多个RPC调用

#### 10.5.3 使用RxJava模拟RPC异步回调

# 读书笔记

## 1.3.2 创建一个空线程

### 划线评论
> 📌 public void run() { ​​​​​​​      if(this.target != null) { ​​​​​​​          this.target.run(); ​​​​​​​      } ​​​​​​​}  ^14417636-7IlDZIxv8
    - 💭 这个比较重要，也就理解了线程创建的几种方式了
    - ⏱ 2023-05-20 13:40:28
   
## 1.4.3 线程的生命周期

### 划线评论
> 📌 NEW（新建）状态、RUNNABLE（可执行）状态、TERMINATED（终止）状态、TIMED_WAITING（限时等待）状态  ^14417636-7I6dX10U1
    - 💭 线程的状态：NEW(新建)、RUNNABLE(可执行)、TERMINATED(终止)、TIMED_WAITING(限时等待)、WAITING(等待)、BLOCKED(阻塞)
    - ⏱ 2023-05-10 10:22:45
   
## 1.5.3 线程的interrupt操作

### 划线评论
> 📌 如果线程的interrupt()方法先被调用，然后线程开始调用阻塞方法进入阻塞状态，InterruptedException异常依旧会抛出  ^14417636-7I6jx44qZ
    - 💭 抛出异常之后，中断状态被清空
而LockSupport.park()则不会清空，需要手动调用Thread.interrupted()
    - ⏱ 2023-05-10 11:47:58

### 划线评论
> 📌 如果线程的interrupt()方法先被调用，然后线程开始调用阻塞方法进入阻塞状态，InterruptedException异常依旧会抛出  ^14417636-7I6j4BarF
    - 💭 线程先调用interrupt()方法中断，再调用Object.wait()、Thread.join()和Thread.sleep()方法，也会抛出异常
    - ⏱ 2023-05-10 11:40:57

### 划线评论
> 📌 如果线程捕获InterruptedException异常后，继续调用阻塞方法，将不再触发InterruptedException异常。  ^14417636-7IlSIIIXt
    - 💭 作者说的意思是这次阻塞捕捉之后，如果再次阻塞，依然会被阻塞(这是因为中断状态会被清空)
    - ⏱ 2023-05-20 17:25:18

### 划线评论
> 📌 线程捕获InterruptedException异常后，继续调用阻塞方法，将不再触发InterruptedException异常  ^14417636-7IlQ7f1sI
    - 💭 这里有点歧义
    - ⏱ 2023-05-20 16:45:32
   
## 1.6.7 任务阻塞队列

### 划线评论
> 📌 暂时  ^14417636-7IlTGuvkK
    - 💭 应该是暂存吧
    - ⏱ 2023-05-20 17:40:02
   
## 3.1.2 使用CAS进行无锁编程

### 划线评论
> 📌 CAS是一种无锁算法，该算法关键依赖两个值——期望值（旧值）和新值，底层CPU利用原子操作判断内存原值与期望值是否相等，如果相等就给内存地址赋新值，否则不做任何操作。  ^14417636-7InMcxGsh
    - 💭 需要结合循环实现
    - ⏱ 2023-05-21 23:19:07
   
## 4.5.2 JMM与JVM物理内存的区别

### 划线评论
> 📌 .2　JMM与JVM物理内存的区  ^14417636-7IsRsOdT5
    - 💭 比较重要
    - ⏱ 2023-05-25 07:32:49
   
## 5.1 显式锁

### 划线评论
> 📌 1）限时抢锁：在抢锁时设置超时时长，如果超时还未获得锁就放弃，不至于无限等下去。
（2）可中断抢锁：在抢锁时，外部线程给抢锁线程发一个中断信号，就能唤起等待锁的线程，并终止抢占过程。
（3）多个等待队列：为锁维持多个等待队列，以便提高锁的效率。比如在生产者-消费者模式实现中，生产者和消费者共用一把锁，该锁上维持两个等待队列，即一个生产者队列和一个消费者队列。  ^14417636-7IrFI015Z
    - 💭 内置锁和显示锁的区别
    - ⏱ 2023-05-24 12:46:39
   
# 本书评论
