---
doc_type: weread-highlights-reviews
bookId: "22730227"
author: 高洪岩
cover: https://cdn.weread.qq.com/weread/cover/39/YueWen_22730227/t7_YueWen_22730227.jpg
reviewCount: 3
noteCount: 41
readingStatus: 读过
progress: 24%
totalReadDay: 5
readingTime: 4小时2分钟
readingDate: 2022-08-14
isbn: 9787111604068
lastReadDate: 2022-08-18

---
# 元数据
> [!abstract] NIO与Socket编程技术指南
> - ![ NIO与Socket编程技术指南|200](https://cdn.weread.qq.com/weread/cover/39/YueWen_22730227/t7_YueWen_22730227.jpg)
> - 书名： NIO与Socket编程技术指南
> - 作者： 高洪岩
> - 简介： 本书共6章，具体内容如下。第1章讲解了NIO中的缓冲区，包括核心API的使用。第2章讲解了NIO中的Channel通道类的继承关系、核心接口的作用。第3章涵盖NetworkInterface类获得网络接口的信息、InetAddress和InterfaceAddress类的常见API。第4章中讲解使用Java语言实现Socket通信，基于TCP/IP和UDP协议进行实现。第5章中讲解了NIO技术中非常重要的Selector选择器技术。第6章异步IO（AIO），在NIO的基础上实现异步执行、回调处理等高级功能。
> - 出版时间 2018-07-01 00:00:00
> - ISBN： 9787111604068
> - 分类： 计算机-编程设计
> - 出版社： 机械工业出版社
> - PC地址：https://weread.qq.com/web/reader/84b32570715ad5f384bcc06

# 高亮划线

## 封面

## 版权信息

## 前言

## 第1章 缓冲区的使用

> 📌  线程、并发处理、NIO及Socket这4种核心技术 ^22730227-4-816-841
- 💭 Java提升必须掌握的技能 - ⏱ 2022-08-14 22:10:29 

> 📌 Socket技术基于TCP/IP 
> ⏱ 2022-08-14 22:17:03 ^22730227-4-4302-4318

> 📌 NIO中的核心通道类都是基于Socket技术的通道类 
> ⏱ 2022-08-14 22:19:13 ^22730227-4-5265-5291

> 📌 NIO相比普通的I/O提供了功能更加强大、处理数据更快的解决方案，它可以大大提高I/O（输入/输出）吞吐量，常用在高性能服务器上 
> ⏱ 2022-08-14 22:20:49 ^22730227-4-5896-5960

> 📌 NIO实现高性能处理的原理是使用较少的线程来处理更多的任务 
> ⏱ 2022-08-14 22:21:02 ^22730227-4-6033-6062

### 1.1 NIO概述

> 📌 NIO在大文件操作上相比常规I/O更加优秀，对常规I/O使用的byte[]或char[]进行封装，采用ByteBuffer类来操作数据，再结合针对File或Socket技术的Channel，采用同步非阻塞技术实现高性能处理。现在主流的高性能服务处理框架Netty正是通过封装了NIO技术来实现的 
> ⏱ 2022-08-17 08:13:32 ^22730227-5-548-695

### 1.2 缓冲区介绍

> 📌 Buffer类是一个抽象类，它具有7个直接子类，分别是ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer，也就是缓冲区中存储的数据类型并不像普通I/O流只能存储byte或char数据类型，Buffer类能存储的数据类型是多样的。 
> ⏱ 2022-08-14 22:27:16 ^22730227-6-1092-1260

> 📌 nio包下并没有提供java.nio.StringBuffer缓冲区，在NIO中存储字符的缓冲区可以使用CharBuffer类。 
> ⏱ 2022-08-14 22:27:46 ^22730227-6-1453-1517

### 1.3 Buffer类的使用

> 📌 因此wrap()就相当于创建这些缓冲区的工厂方法 
> ⏱ 2022-08-14 22:32:27 ^22730227-7-5876-5900

> 📌 ByteBuffer类缓冲区的技术原理就是使用byte[]数组进行数据的保存，在后续使用指定的API来操作这个数组以达到操作缓冲区的目的 
> ⏱ 2022-08-14 22:33:33 ^22730227-7-6356-6424

> 📌 缓冲区存储的数据还是存储在byte[]字节数组中。使用缓冲区与使用byte[]字节数组的优点在于缓冲区将存储数据的byte[]字节数组内容与相关的信息整合在1个Buffer类中，将数据与缓冲区中的信息进行了整合，并进行了封装，这样便于获得相关的信息及处理数据。 
> ⏱ 2022-08-14 22:36:17 ^22730227-7-7002-7132

> 📌 什么是限制呢？缓冲区中的限制代表第一个不应该读取或写入元素的index（索引） 
> ⏱ 2022-08-14 22:38:10 ^22730227-7-7719-7758

> 📌 如果position大于新的limit，则将position设置为新的limit。 
> ⏱ 2022-08-14 23:01:16 ^22730227-7-7798-7839

> 📌 限制（limit）代表第一个不应该读取或写入元素的index，缓冲区的limit不能为负，并且limit不能大于其capacity 
> ⏱ 2022-08-14 22:41:42 ^22730227-7-7937-8002

> 📌 Limit使用的场景就是当反复地向缓冲区中存取数据时使用 
> ⏱ 2022-08-14 22:46:40 ^22730227-7-9675-9703

> 📌 什么是位置呢？它代表“下一个”要读取或写入元素的index（索引），缓冲区的position（位置）不能为负，并且position不能大于其limit 
> ⏱ 2022-08-14 22:47:41 ^22730227-7-10697-10772

> 📌 方法int remaining()的作用：返回“当前位置”与limit之间的元素数。 
> ⏱ 2022-08-14 22:49:03 ^22730227-7-12297-12339

> 📌 缓冲区的标记是一个索引，在调用reset()方法时，会将缓冲区的position位置重置为该索引。标记（mark）并不是必需的。 
> ⏱ 2022-08-14 22:53:56 ^22730227-7-13919-13983

> 📌 缓冲区中的mark有些类似于探险或爬山时在关键路口设置“路标”，目的是在原路返回时找到回去的路。 
> ⏱ 2022-08-14 22:54:40 ^22730227-7-14161-14209

> 📌 通过ByteBuffer向硬盘存取数据时是需要将数据暂存在JVM的中间缓冲区，如果有频繁操作数据的情况发生，则在每次操作时都会将数据暂存在JVM的中间缓冲区，再交给ByteBuffer处理，这样做就大大降低软件对数据的吞吐量，提高内存占有率，造成软件运行效率降低，这就是非直接缓冲区保存数据的过程，所以非直接缓冲区的这个弊端就由直接缓冲区解决了。 
> ⏱ 2022-08-14 23:08:11 ^22730227-7-28909-29082

> 📌 final Buffer flip()方法常用在向缓冲区中写入一些数据后，下一步读取缓冲区中的数据之前，以改变limit与position的值。 
> ⏱ 2022-08-14 23:14:43 ^22730227-7-33205-33277

> 📌 final boolean hasArray()方法的作用：判断此缓冲区是否具有可访问的底层实现数组。 
> ⏱ 2022-08-14 23:19:36 ^22730227-7-38581-38632

> 📌 final Buffer rewind()方法的作用：重绕此缓冲区，将位置设置为0并丢弃标记 
> ⏱ 2022-08-14 23:25:59 ^22730227-7-42386-42432

> 📌 rewind()方法常在重新读取缓冲区中数据时使用。 
> ⏱ 2022-08-14 23:31:30 ^22730227-7-42965-42991

> 📌 方法clear()的主要使用场景是在对缓冲区进行存储数据之前调用此方法。 
> ⏱ 2022-08-14 23:31:43 ^22730227-7-43243-43279

> 📌 flip()方法的通俗解释是“缩小limit的范围，类似于String.subString(0, endIndex)方法” 
> ⏱ 2022-08-14 23:32:11 ^22730227-7-43778-43839

> 📌 ❑rewind()：使缓冲区为“重新读取”已包含的数据做好准备，它使限制保持不变，将位置设置为0。
❑clear()：使缓冲区为一系列新的通道读取或相对put(value)操作做好准备，即它将限制设置为容量大小，将位置设置为0。
❑flip()：使缓冲区为一系列新的通道写入或相对get(value)操作做好准备，即它将限制设置为当前位置，然后将位置设置为0。
这3个方法的侧重点在于：
1）rewind()方法的侧重点在“重新”，在重新读取、重新写入时可以使用；
2）clear()方法的侧重点在“还原一切状态”；
3）flip()方法的侧重点在substring截取。 
> ⏱ 2022-08-14 23:32:46 ^22730227-7-43938-44394

### 1.4 ByteBuffer类的使用

> 📌 ByteBuffer类是Buffer类的子类，可以在缓冲区中以字节为单位对数据进行存取，而且它也是比较常用和重要的缓冲区类 
> ⏱ 2022-08-15 00:05:40 ^22730227-8-442-503

> 📌 [插图] 
> ⏱ 2022-08-15 22:30:28 ^22730227-8-804-805

> 📌 字节缓冲区可以通过allocation()方法创建，此方法为缓冲区的内容分配空间，或者通过wrapping方法将现有的byte[]数组包装到缓冲区中来创建。 
> ⏱ 2022-08-15 22:35:21 ^22730227-8-1550-1628

> 📌 字节缓冲区分为直接字节缓冲区与非直接字节缓冲区。 
> ⏱ 2022-08-15 22:35:09 ^22730227-8-1805-1829

> 📌 直接缓冲区操作的数据不在JVM堆中，而是在内核空间中，根据这个结构可以分析出，直接缓冲区善于保存那些易受操作系统本机I/O操作影响的大量、长时间保存的数据 
> ⏱ 2022-08-15 22:36:58 ^22730227-8-2126-2203

> 📌 allocateDirect(int capacity)方法的作用：分配新的直接字节缓冲区。新缓冲区的位置将为零，其界限将为其容量，其标记是不确定的。无论它是否具有底层实现数组，其标记都是不确定的。
allocate(int capacity)方法的作用：分配一个新的非直接字节缓冲区。新缓冲区的位置为零，其界限将为其容量，其标记是不确定的。它将具有一个底层实现数组，且其数组偏移量将为零。 
> ⏱ 2022-08-15 22:38:04 ^22730227-8-2233-2456

> 📌 使用allocateDirect()方法创建出来的缓冲区类型为DirectByteBuffer，使用allocate()方法创建出来的缓冲区类型为HeapByteBuffer。 
> ⏱ 2022-08-15 00:10:37 ^22730227-8-3790-3878

> 📌 使用allocateDirect()方法创建ByteBuffer缓冲区时，capacity指的是字节的个数，而创建IntBuffer缓冲区时，capacity指的是int值的数目，如果要转换成字节，则capacity的值要乘以4，来算出占用的总字节数。 
> ⏱ 2022-08-16 20:24:30 ^22730227-8-3907-4033

> 📌 直接缓冲区是使用DirectByteBuffer类进行实现的，而非直接缓冲区是使用HeapByteBuffer类进行实现的 
> ⏱ 2022-08-15 00:13:24 ^22730227-8-8055-8116

### 1.5 CharBuffer类的API使用

### 1.6 小结

## 第2章 通道和FileChannel类的使用

### 2.1 通道概述

> 📌 NIO技术中的数据要放在缓冲区中进行管理，再使用通道将缓冲区中的数据传输到目的地 
> ⏱ 2022-08-15 00:41:43 ^22730227-12-1180-1220

### 2.2 通道接口的层次结构

> 📌 通道是用于I/O操作的连接，更具体地讲，通道代表数据到硬件设备、文件、网络套接字的连接 
> ⏱ 2022-08-17 08:20:28 ^22730227-13-2741-2784

### 2.3 AbstractInterruptibleChannel类的介绍

### 2.4 FileChannel类的使用

> 📌 FileChannel类的主要作用是读取、写入、映射和操作文件的通道。该通道永远是阻塞的操作 
> ⏱ 2022-08-17 08:25:42 ^22730227-15-444-490

### 2.5 小结

## 第3章 获取网络设备信息

### 3.1 NetworkInterface类的常用方法

### 3.2 NetworkInterface类的静态方法

### 3.3 小结

## 第4章 实现Socket通信

### 4.1 基于TCP的Socket通信

> 📌 Socket连接后，无论是否使用这个连接，该连接都保持连接的状态。 
> ⏱ 2022-08-18 12:42:36 ^22730227-22-604-637

> 📌 长连接就是复用当前的连接以达到数据多次通信的目的。 
> ⏱ 2022-08-18 12:44:27 ^22730227-22-1051-1076

### 4.2 ServerSocket类的使用

### 4.3 Socket类的使用

### 4.4 基于UDP的Socket通信

### 4.5 小结

## 第5章 选择器的使用

### 5.1 选择器与I/O多路复用

### 5.2 核心类Selector、SelectionKey和SelectableChannel的关系

### 5.3 通道类AbstractInterruptibleChannel与接口InterruptibleChannel的介绍

### 5.4 通道类SelectableChannel的介绍

### 5.5 通道类AbstractSelectableChannel的介绍

### 5.6 通道类ServerSocketChannel与接口NetworkChannel的介绍

### 5.7 ServerSocketChannel类、Selector和SelectionKey的使用

### 5.8 Selector类的使用

### 5.9 SelectionKey类的使用

### 5.10 DatagramChannel类的使用

### 5.11 Pipe.SinkChannel和Pipe.SourceChannel类的使用

### 5.12 SelectorProvider类的使用

### 5.13 小结

## 第6章 AIO的使用

### 6.1 AsynchronousFileChannel类的使用

### 6.2 AsynchronousServerSocketChannel和AsynchronousSocketChannel类的使用

### 6.3 同步、异步、阻塞与非阻塞之间的关系

### 6.4 小结

# 读书笔记

## 第1章 缓冲区的使用

### 划线评论
> 📌 线程、并发处理、NIO及Socket这4种核心技术  ^14417636-7BvN5VcjN
    - 💭 Java提升必须掌握的技能
    - ⏱ 2022-08-14 22:11:04
   
## 1.1 NIO概述

### 划线评论
> 📌 NIO在大文件操作上相比常规I/O更加优秀，对常规I/O使用的byte[]或char[]进行封装，采用ByteBuffer类来操作数据，再结合针对File或Socket技术的Channel，采用同步非阻塞技术实现高性能处理。  ^14417636-7BvNVO4sv
    - 💭 NIO是同步非阻塞的，AIO是异步非阻塞的
    - ⏱ 2022-08-14 22:23:51
   
## 1.3 Buffer类的使用

### 划线评论
> 📌 ByteBuffer.allocateDirect(100);  ^14417636-7BvQT021f
    - 💭 申请直接缓冲区
    - ⏱ 2022-08-14 23:08:58
   
# 本书评论
