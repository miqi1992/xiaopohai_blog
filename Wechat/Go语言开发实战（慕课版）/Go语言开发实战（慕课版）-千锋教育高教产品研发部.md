---
doc_type: weread-highlights-reviews
bookId: "28438052"
author: 千锋教育高教产品研发部
cover: https://wfqqreader-1252317822.image.myqcloud.com/cover/52/28438052/t7_28438052.jpg
reviewCount: 0
noteCount: 20
readingStatus: 读过
progress: 32%
totalReadDay: 15
readingTime: 4小时16分钟
readingDate: 2020-11-11
isbn: 9787115515780
lastReadDate: 2020-11-24

---
# 元数据
> [!abstract] Go语言开发实战（慕课版）
> - ![ Go语言开发实战（慕课版）|200](https://wfqqreader-1252317822.image.myqcloud.com/cover/52/28438052/t7_28438052.jpg)
> - 书名： Go语言开发实战（慕课版）
> - 作者： 千锋教育高教产品研发部
> - 简介： 本书共有14章，内容包括：初识Go语言、Go语言的基本语法、Go语言的流程控制、函数与指针、Go语言的内置容器、Go语言的常用内置包、Go语言面向对象编程、Go语言异常处理、Go语言文件IO操作、Go语言网络编程、Go语言数据库编程、Go语言并发编程、Go语言密码学算法、Beego框架项目实战。
> - 出版时间 2019-12-01 00:00:00
> - ISBN： 9787115515780
> - 分类： 计算机-编程设计
> - 出版社： 人民邮电出版社
> - PC地址：https://weread.qq.com/web/reader/df83279071b1ee24df86404

# 高亮划线

## 封面

## 版权信息

## 内容提要

## 编委会

## 前言

## 第1章 初识Go语言

### 1.1 Go语言的发展历史

### 1.2 Go语言的特性

#### 1.2.1 Go语言的特点和优势

> 📌 Goroutine类似于线程，但并非线程，是Go面向线程的轻量级方法。创建Goroutine的成本很低，只需几千个字节的额外内存。通常一台普通的桌面主机运行上百个线程就会负载过大， 
> ⏱ 2020-11-11 08:15:52 ^28438052-9-1294-1384

#### 1.2.2 使用Go语言的项目与企业

### 1.3 安装和配置Golang

#### 1.3.1 Windows版本安装

#### 1.3.2 Mac OS版本安装

#### 1.3.3 Linux版本安装

### 1.4 搭建集成开发环境GoLand

#### 1.4.1 GoLand的下载及安装

#### 1.4.2 GoLand的使用

#### 1.4.3 编写第一个程序HelloWorld

#### 1.4.4 GoLand的快捷键

### 1.5 Go语言的结构组成及编码规范

#### 1.5.1 Go语言的结构组成

#### 1.5.2 Go语言的标识符

#### 1.5.3 Go语言的编码规范

### 1.6 本章小结

### 1.7 习题

## 第2章 Go语言的基本语法

### 2.1 变量

#### 2.1.1 变量的概念

#### 2.1.2 变量声明

#### 2.1.3 变量多重赋值

#### 2.1.4 匿名变量

### 2.2 数据类型

#### 2.2.1 整型

#### 2.2.2 浮点型

#### 2.2.3 复数型

#### 2.2.4 布尔型

#### 2.2.5 字符串

#### 2.2.6 字符

### 2.3 打印格式化

#### 2.3.1 通用打印格式

#### 2.3.2 布尔型打印格式

#### 2.3.3 整型打印格式

#### 2.3.4 浮点型与复数型的打印格式

#### 2.3.5 字符串与字节数组的打印格式

### 2.4 数据类型转换

#### 2.4.1 基本语法

#### 2.4.2 浮点型与整型之间转换

#### 2.4.3 整型转字符串类型

### 2.5 常量

#### 2.5.1 声明方式

#### 2.5.2 常量用于枚举

#### 2.5.3 iota

### 2.6 类型别名与类型定义

### 2.7 Go语言的运算符

#### 2.7.1 算术运算符

#### 2.7.2 关系运算符

#### 2.7.3 逻辑运算符

#### 2.7.4 位运算符

#### 2.7.5 赋值运算符

#### 2.7.6 其他运算符

### 2.8 运算符优先级

### 2.9 本章小结

### 2.10 习题

## 第3章 Go语言的流程控制

### 3.1 流程控制概述

#### 3.1.1 条件判断语句

#### 3.1.2 条件分支语句

#### 3.1.3 循环语句

#### 3.1.4 循环控制语句

### 3.2 if条件判断语句

#### 3.2.1 语法结构

> 📌 在if之后，条件语句之前，可以添加变量初始化语句，使用“;”进行分隔。 
> ⏱ 2020-11-16 08:06:30 ^28438052-71-1648-1683

#### 3.2.2 使用案例

#### 3.2.3 特殊写法

### 3.3 if嵌套语句

#### 3.3.1 语法结构

#### 3.3.2 使用案例

### 3.4 switch分支语句

#### 3.4.1 语法结构

#### 3.4.2 使用案例

#### 3.4.3 类型转换

### 3.5 for循环语句

#### 3.5.1 语法结构

#### 3.5.2 使用案例

### 3.6 for嵌套循环语句

#### 3.6.1 语法结构

#### 3.6.2 使用案例

### 3.7 循环控制语句

#### 3.7.1 break语句

#### 3.7.2 continue语句

#### 3.7.3 goto语句

### 3.8 本章小结

### 3.9 习题

## 第4章 Go语言的函数与指针

### 4.1 函数

#### 4.1.1 函数声明

> 📌 普通函数需要先声明才能调用，一个函数的声明包括参数和函数名等 
> ⏱ 2020-11-20 20:25:48 ^28438052-95-413-443

> 📌 funcName：函数名。函数名和参数列表一起构成了函数签名。 
> ⏱ 2020-11-20 20:26:50 ^28438052-95-822-853

> 📌 在同一个包内，函数不能重名。 
> ⏱ 2020-11-20 20:27:16 ^28438052-95-884-898

> 📌 Go语言的函数可以返回多个值 
> ⏱ 2020-11-20 20:39:16 ^28438052-95-1132-1146

#### 4.1.2 变量作用域

> 📌 Go语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。 
> ⏱ 2020-11-20 20:45:43 ^28438052-96-651-691

#### 4.1.3 函数变量（函数作为值）

#### 4.1.4 匿名函数

> 📌 匿名函数经常被用于实现回调函数、闭包等 
> ⏱ 2020-11-21 09:23:23 ^28438052-98-517-536

#### 4.1.5 闭包

> 📌 函数 + 引用环境 = 闭包 
> ⏱ 2020-11-23 21:18:02 ^28438052-99-653-667

> 📌 闭包只是在形式和表现上像函数，但实际上不是函数 
> ⏱ 2020-11-23 21:18:13 ^28438052-99-697-720

> 📌 函数是编译器静态的概念，而闭包是运行期动态的概念。 
> ⏱ 2020-11-23 08:21:33 ^28438052-99-929-954

> 📌 对象是附有行为的数据，而闭包是附有数据的行为 
> ⏱ 2020-11-23 21:18:56 ^28438052-99-983-1005

> 📌 函数是一阶值（First-class value，一等公民），即函数可以作为另一个函数的返回值或参数，还可以作为一个变量的值。 
> ⏱ 2020-11-23 21:21:02 ^28438052-99-1525-1588

> 📌 由于闭包函数“捕获”了和它在同一作用域的其他常量和变量，所以当闭包在任何地方被调用，闭包都可以使用这些常量或者变量。它不关心这些变量是否已经超出作用域，只要闭包还在使用这些变量，这些变量就依然存在。 
> ⏱ 2020-11-23 21:29:07 ^28438052-99-3908-4007

#### 4.1.6 可变参数

#### 4.1.7 递归函数

### 4.2 指针

#### 4.2.1 指针的概念

> 📌 指针不能运算（不同于C语言）。 
> ⏱ 2020-11-23 21:38:56 ^28438052-103-1562-1577

#### 4.2.2 声明指针

#### 4.2.3 空指针

#### 4.2.4 使用指针

#### 4.2.5 指针数组

#### 4.2.6 指针的指针

### 4.3 函数的参数传递

#### 4.3.1 值传递（传值）

#### 4.3.2 引用传递（传引用）

> 📌 Go语言中slice、map、chan类型的实现机制都类似指针，所以可以直接传递，而不必取地址后传递指针 
> ⏱ 2020-11-24 13:16:11 ^28438052-111-991-1043

#### 4.3.3 值传递和引用传递的细节问题

> 📌 Go语言中所有的传参都是值传递（传值），都是一个副本。副本的内容有的是值类型（int、string、bool、array、struct属于值类型），这样在函数中就无法修改原内容数据；有的是引用类型（pointer、 slice、map、chan属于引用类型），这样就可以修改原内容数据。 
> ⏱ 2020-11-23 22:13:51 ^28438052-112-422-565

> 📌 Go语言中所有的传参都是值传递（传值），都是一个副本。 
> ⏱ 2020-11-23 22:11:48 ^28438052-112-422-449

### 4.4 本章小结

### 4.5 习题

## 第5章 Go语言的内置容器

### 5.1 数组

#### 5.1.1 数组的概念

#### 5.1.2 数组的语法

#### 5.1.3 数组的长度

#### 5.1.4 遍历数组

#### 5.1.5 多维数组

#### 5.1.6 数组是值类型

### 5.2 切片

#### 5.2.1 切片的概念

#### 5.2.2 切片的语法

#### 5.2.3 len()和cap()函数

#### 5.2.4 切片是引用类型

#### 5.2.5 append()和copy()函数

### 5.3 map

#### 5.3.1 map的概念

> 📌 Go 语言提供了内置类型 map，它将一个值与一个键关联起来，可以使用相应的键检索值。这种结构在其他资料中译成地图、映射或字典，但是在Go语言中习惯上翻译成集合 
> ⏱ 2020-11-24 13:13:57 ^28438052-130-744-824

> 📌 内置的len()函数同样适用于map，返回map拥有的键值对的数量。但是map不能通过cap()函数计算容量（或者说cap()函数的参数不可以是map）。 
> ⏱ 2020-11-24 13:14:45 ^28438052-130-1104-1181

#### 5.3.2 map的语法

#### 5.3.3 delete()函数

#### 5.3.4 map是引用类型

### 5.4 本章小结

### 5.5 习题

## 第6章 Go语言的常用内置包

### 6.1 字符串处理概述

#### 6.1.1 字符串处理包简介

#### 6.1.2 字符串的遍历

### 6.2 strings包的字符串处理函数

#### 6.2.1 检索字符串

#### 6.2.2 分割字符串

#### 6.2.3 大小写转换

#### 6.2.4 修剪字符串

#### 6.2.5 比较字符串

### 6.3 strconv包的常用函数

#### 6.3.1 Parse类函数

#### 6.3.2 Format类函数

### 6.4 regexp正则表达式包

#### 6.4.1 正则表达式简介

#### 6.4.2 正则表达式中主要元字符

#### 6.4.3 regexp包中核心函数及方法介绍

### 6.5 time包

### 6.6 math包

### 6.7 随机数

#### 6.7.1 rand包的核心方法介绍

#### 6.7.2 获取随机数的几种方式

### 6.8 键盘输入

#### 6.8.1 Scanln()函数

#### 6.8.2 随机数+键盘输入案例——猜数字游戏

### 6.9 本章小结

### 6.10 习题

## 第7章 Go语言面向对象编程

### 7.1 面向对象思想概述

#### 7.1.1 面向过程与面向对象

#### 7.1.2 Go语言面向对象

### 7.2 结构体

#### 7.2.1 定义结构体与实例化

#### 7.2.2 结构体的语法糖

#### 7.2.3 结构体是值类型

#### 7.2.4 结构体的深拷贝和浅拷贝

#### 7.2.5 结构体作为函数的参数及返回值

#### 7.2.6 匿名结构体和匿名字段

#### 7.2.7 结构体嵌套

### 7.3 方法

#### 7.3.1 方法的概念

#### 7.3.2 基本语法

#### 7.3.3 方法和函数

#### 7.3.4 方法继承

#### 7.3.5 方法重写

### 7.4 接口

#### 7.4.1 接口的概念

#### 7.4.2 接口的定义与实现

#### 7.4.3 duck typing

#### 7.4.4 多态

#### 7.4.5 空接口

#### 7.4.6 接口对象转型

### 7.5 本章小结

### 7.6 习题

## 第8章 Go语言异常处理

### 8.1 error

#### 8.1.1 error接口

#### 8.1.2 创建error对象

#### 8.1.3 自定义错误

### 8.2 defer

#### 8.2.1 函数中使用defer

#### 8.2.2 方法中使用defer

#### 8.2.3 defer参数

#### 8.2.4 堆栈的推迟

### 8.3 panic和recover机制

#### 8.3.1 panic

#### 8.3.2 recover

### 8.4 本章小结

### 8.5 习题

## 第9章 Go语言文件I/O操作

### 9.1 文件信息

#### 9.1.1 文件概述

#### 9.1.2 FileInfo接口

#### 9.1.3 文件路径

### 9.2 文件常规操作

#### 9.2.1 创建目录

#### 9.2.2 创建文件

#### 9.2.3 打开和关闭文件

#### 9.2.4 删除文件

### 9.3 读写文件及复制文件

#### 9.3.1 读取文件

#### 9.3.2 写入文件

#### 9.3.3 复制文件

### 9.4 ioutil包

#### 9.4.1 ioutil包核心函数

#### 9.4.2 示例代码

### 9.5 bufio包

#### 9.5.1 缓冲区的原理

#### 9.5.2 bufio.Reader结构体

#### 9.5.3 bufio.Writer结构体

#### 9.5.4 Scanner

### 9.6 本章小结

### 9.7 习题

## 第10章 Go语言网络编程

### 10.1 HTTP概述

#### 10.1.1 HTTP的概念

#### 10.1.2 HTTP请求方法

#### 10.1.3 HTTPS通信原理

#### 10.1.4 HTTPS的作用

### 10.2 HTTP协议客户端实现

### 10.3 HTTP协议服务端实现

#### 10.3.1 启动Web服务的几种方式

#### 10.3.2 服务器端获取客户端请求的数据

### 10.4 Golang模板

#### 10.4.1 模板的概念

#### 10.4.2 基本语法

### 10.5 JSON编码

#### 10.5.1 JSON简介

#### 10.5.2 map转JSON

#### 10.5.3 结构体转JSON

#### 10.5.4 结构体字段标签

#### 10.5.5 匿名字段

#### 10.5.6 注意事项

### 10.6 JSON解析

#### 10.6.1 JSON转切片

#### 10.6.2 JSON转结构体

#### 10.6.3 结构体字段标签

#### 10.6.4 匿名字段

### 10.7 本章小结

### 10.8 习题

## 第11章 Go语言数据库编程

### 11.1 数据库介绍

### 11.2 MySQL数据库的使用

#### 11.2.1 服务启动和停止MySQL服务

#### 11.2.2 登录和退出MySQL数据库

#### 11.2.3 MySQL数据库基本操作

### 11.3 MySQL数据类型

#### 11.3.1 数值类型

#### 11.3.2 日期时间类型

#### 11.3.3 字符串类型

### 11.4 SQL基础入门

#### 11.4.1 SQL语言简介

#### 11.4.2 SQL分类

#### 11.4.3 DDL语句基本用法

#### 11.4.4 DML语句基本用法

#### 11.4.5 DQL语句基本用法

### 11.5 Go程序操作MySQL数据库

#### 11.5.1 安装MySQL模块

#### 11.5.2 导入包

#### 11.5.3 连接数据库

#### 11.5.4 增删改数据

#### 11.5.5 查询数据

#### 11.5.6 示例代码

### 11.6 本章小结

### 11.7 习题

## 第12章 Go语言并发编程

### 12.1 并发和并行

#### 12.1.1 单道程序与多道程序

#### 12.1.2 并发与并行的区别

### 12.2 进程和线程

#### 12.2.1 程序与进程

#### 12.2.2 进程与线程的区别

#### 12.2.3 进程与线程的联系

### 12.3 Goroutine

#### 12.3.1 协程的概念

#### 12.3.2 Go语言中的协程

#### 12.3.3 Coroutine与Goroutine

#### 12.3.4 普通函数创建Goroutine

#### 12.3.5 匿名函数创建Goroutine

#### 12.3.6 启动多个Goroutine

#### 12.3.7 调整并发的运行性能

### 12.4 channel

#### 12.4.1 channel的概述

#### 12.4.2 创建channel类型

#### 12.4.3 使用channel发送数据

#### 12.4.4 通过channel接收数据

#### 12.4.5 阻塞

#### 12.4.6 关闭channel

#### 12.4.7 缓冲channel

#### 12.4.8 单向channel

### 12.5 time包中与channel相关的函数

#### 12.5.1 Timer结构体

#### 12.5.2 NewTimer()函数

#### 12.5.3 After()函数

### 12.6 select分支语句

#### 12.6.1 执行流程

#### 12.6.2 示例代码

### 12.7 sync包

#### 12.7.1 同步等待组

#### 12.7.2 互斥锁

#### 12.7.3 读写互斥锁

#### 12.7.4 条件变量

### 12.8 本章小结

### 12.9 习题

## 第13章 Go语言密码学算法

### 13.1 Hash算法

#### 13.1.1 Hash的定义

#### 13.1.2 流行的Hash算法

#### 13.1.3 Hash与加密解密的区别

#### 13.1.4 SHA-256

#### 13.1.5 核心代码

### 13.2 对称加密算法

#### 13.2.1 对称加密简介

#### 13.2.2 DES和3DES算法

#### 13.2.3 AES算法

#### 13.2.4 AES的加密模式

#### 13.2.5 填充方式

#### 13.2.6 核心代码

### 13.3 非对称加密算法

#### 13.3.1 非对称加密简介

#### 13.3.2 非对称加密算法实现数字签名

#### 13.3.3 RSA算法

#### 13.3.4 核心代码

### 13.4 椭圆曲线加密算法和椭圆曲线数字签名算法

#### 13.4.1 椭圆曲线加密简介

#### 13.4.2 数字签名的概念

#### 13.4.3 核心代码

### 13.5 字符编码与解码

#### 13.5.1 Base64

#### 13.5.2 Base58

### 13.6 本章小结

### 13.7 习题

## 第14章 Beego框架项目实战

### 14.1 Beego框架介绍及项目初始化配置

#### 14.1.1 Beego简介

#### 14.1.2 Beego框架的主要特性

#### 14.1.3 Beego安装

#### 14.1.4 bee工具的使用

#### 14.1.5 创建项目

#### 14.1.6 结构分析

#### 14.1.7 路由设置

### 14.2 Elm后台管理平台项目介绍

#### 14.2.1 项目介绍

#### 14.2.2 项目效果展示

#### 14.2.3 整体架构简介

### 14.3 数据库配置及ORM映射

#### 14.3.1 ORM简介

#### 14.3.2 Beego项目中使用MySQL

#### 14.3.3 数据导入

#### 14.3.4 接口文档说明

#### 14.3.5 模块开发

#### 14.3.6 数据格式封装

### 14.4 Redis

#### 14.4.1 Redis简介

#### 14.4.2 Redis安装

#### 14.4.3 Redis操作与使用

#### 14.4.4 项目中使用Redis

#### 14.4.5 登录管理员退出操作

#### 14.4.6 文件操作

#### 14.4.7 数据库表关系映射

### 14.5 项目功能完善

#### 14.5.1 商户模块功能开发

#### 14.5.2 食品模块功能开发

#### 14.5.3 订单模块功能开发

#### 14.5.4 添加数据记录模块开发

### 14.6 本章小结

### 14.7 习题

# 读书笔记

# 本书评论
